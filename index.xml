<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XIZERO</title>
    <link>https://www.xizero.com/index.xml</link>
    <description>Recent content on XIZERO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Jan 2017 12:00:00 +0800</lastBuildDate>
    <atom:link href="https://www.xizero.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java 开发环境恢复手册</title>
      <link>https://www.xizero.com/tool/Java%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%81%A2%E5%A4%8D%E6%89%8B%E5%86%8C/</link>
      <pubDate>Fri, 20 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/tool/Java%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%81%A2%E5%A4%8D%E6%89%8B%E5%86%8C/</guid>
      <description>

&lt;h2 id=&#34;notepad&#34;&gt;Notepad++&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://notepad-plus-plus.org/&#34;&gt;https://notepad-plus-plus.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git-for-windows&#34;&gt;Git for Windows&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://git-scm.com/&#34;&gt;https://git-scm.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;添加快捷方式到桌面&lt;/p&gt;

&lt;p&gt;添加 git bash 到右键菜单&lt;/p&gt;

&lt;h3 id=&#34;更换主题&#34;&gt;更换主题&lt;/h3&gt;

&lt;p&gt;网址：&lt;a href=&#34;http://ciembor.github.io/4bit/&#34;&gt;http://ciembor.github.io/4bit/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编辑用户目录下的 .minttyrc 文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;BoldAsFont=-1
Columns=99
Rows=33
Font=Lucida Console
FontHeight=12
BackgroundColour=13,25,38
ForegroundColour=217,230,242
CursorColour=217,230,242
Black=0,0,0
BoldBlack=38,38,38
Red=184,122,122
BoldRed=219,189,189
Green=122,184,122
BoldGreen=189,219,189
Yellow=184,184,122
BoldYellow=219,219,189
Blue=122,122,184
BoldBlue=189,189,219
Magenta=184,122,184
BoldMagenta=219,189,219
Cyan=122,184,184
BoldCyan=189,219,219
White=217,217,217
BoldWhite=255,255,255
Locale=C
Charset=GBK
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配置文件&#34;&gt;配置文件&lt;/h3&gt;

&lt;p&gt;配置用户名和邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global user.name &amp;quot;[name]&amp;quot;
git config --global user.email &amp;quot;[email]&amp;quot;
git config --global color.ui true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印全局配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ssh-key&#34;&gt;SSH key&lt;/h3&gt;

&lt;p&gt;检查用户目录下是否存在隐藏文件夹 .ssh&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成SSH Key，在 &lt;code&gt;.ssh/id_rsa.pub&lt;/code&gt; 中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh-keygen -t rsa -C &amp;quot;your_email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Github 中添加，并测试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;source-tree&#34;&gt;Source Tree&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://www.sourcetreeapp.com/&#34;&gt;https://www.sourcetreeapp.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装配置&#34;&gt;安装配置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;跳过默认设置&lt;/li&gt;
&lt;li&gt;使用系统Git&lt;/li&gt;
&lt;li&gt;添加 SSH key&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;hugo&#34;&gt;Hugo&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://gohugo.io/&#34;&gt;https://gohugo.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装-1&#34;&gt;安装&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;解压，重命名为 hugo.exe ，放在 &lt;code&gt;D:/Software/hugo/bin/&lt;/code&gt; 下&lt;/li&gt;
&lt;li&gt;配置环境变量 Path&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;visual-studio-code&#34;&gt;Visual Studio Code&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;jdk&#34;&gt;JDK&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/index.html&#34;&gt;http://www.oracle.com/technetwork/java/javase/downloads/index.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;配置环境变量&#34;&gt;配置环境变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JAVA_HOME&lt;/li&gt;
&lt;li&gt;Path

&lt;ul&gt;
&lt;li&gt;%JAVA_HOME%\bin;&lt;/li&gt;
&lt;li&gt;%JAVA_HOME%\jre\bin;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tomcat&#34;&gt;Tomcat&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;http://tomcat.apache.org/&#34;&gt;http://tomcat.apache.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载执行文件安装&lt;/p&gt;

&lt;h2 id=&#34;maven&#34;&gt;Maven&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://maven.apache.org/&#34;&gt;https://maven.apache.org/&lt;/a&gt;
Maven Repository：&lt;a href=&#34;https://mvnrepository.com/&#34;&gt;Maven Repository&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装配置-1&#34;&gt;安装配置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;解压到 &lt;code&gt;C:\Program Files\Apache Software Foundation&lt;/code&gt; 下，重命名为 Maven&lt;/li&gt;
&lt;li&gt;配置环境变量

&lt;ul&gt;
&lt;li&gt;MAVEN_HOME&lt;/li&gt;
&lt;li&gt;Path

&lt;ul&gt;
&lt;li&gt;%MAVEN_HOME%\bin&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;修改配置文件 &lt;code&gt;conf/setting.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;设置本地仓库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;localRepository&amp;gt;d:/m2/repository&amp;lt;/localRepository&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置远程仓库镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;nexus-aliyun&amp;lt;/id&amp;gt;
    &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;ben
    &amp;lt;name&amp;gt;Nexus aliyun&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public&amp;lt;/url&amp;gt;
&amp;lt;/mirror&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;intelij-idea&#34;&gt;InteLiJ IDEA&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;https://www.jetbrains.com/idea/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;登陆激活&lt;/li&gt;
&lt;li&gt;去掉不需要的插件&lt;/li&gt;
&lt;li&gt;设置默认设置

&lt;ul&gt;
&lt;li&gt;设置默认Maven&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;idea新建maven项目卡住显示-generating-project-in-batch-mode&#34;&gt;IDEA新建MAVEN项目卡住显示 : &amp;ldquo;Generating Project in Batch mode&amp;rdquo;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;下载 &lt;code&gt;archetype-catalog.xml&lt;/code&gt;  - -  &lt;a href=&#34;http://repo.maven.apache.org/maven2/&#34;&gt;http://repo.maven.apache.org/maven2/&lt;/a&gt;，找到 &lt;code&gt;archetype-catalog.xml&lt;/code&gt; ,右键保存&lt;/li&gt;
&lt;li&gt;放到 &amp;ldquo;.m2\repository\org\apache\maven\archetype\archetype-catalog\2.4&amp;rdquo; 下&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Settings&lt;/code&gt;&amp;gt; &lt;code&gt;Maven&lt;/code&gt; &amp;gt; &lt;code&gt;Runner&lt;/code&gt; &amp;gt; &lt;code&gt;VM Options&lt;/code&gt; 中添加 &lt;code&gt;-DarchetypeCatalog=internal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PS：注意右上角的灰字：for default project，而不是for current project&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>win10 系统恢复手册</title>
      <link>https://www.xizero.com/tool/win10%20%E7%B3%BB%E7%BB%9F%E6%81%A2%E5%A4%8D%E6%89%8B%E5%86%8C/</link>
      <pubDate>Thu, 19 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/tool/win10%20%E7%B3%BB%E7%BB%9F%E6%81%A2%E5%A4%8D%E6%89%8B%E5%86%8C/</guid>
      <description>

&lt;h2 id=&#34;系统安装&#34;&gt;系统安装&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;断网安装，创建本地英文账户&lt;/li&gt;
&lt;li&gt;禁止预装应用自动安装

&lt;ul&gt;
&lt;li&gt;打开注册表 regedit&lt;/li&gt;
&lt;li&gt;进入路径 &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;右键点击新建项“CloudContent&lt;/li&gt;
&lt;li&gt;双击新建的CloudContent，在右栏右键新建DWORD (32位) 值或新建DWORD (64位)值，并命名为DisableWindowsConsumerFeatures&lt;/li&gt;
&lt;li&gt;双击DisableWindowsConsumerFeatures，在数值数据输入1，确定&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设置资源管理器默认打开我的电脑&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;连接网络-配置系统&#34;&gt;连接网络，配置系统&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Flower Password  - - &lt;a href=&#34;https://flowerpassword.com/&#34;&gt;https://flowerpassword.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;YoMail - - &lt;a href=&#34;http://www.yomail.com/&#34;&gt;http://www.yomail.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;登陆微软账号，激活系统&lt;/li&gt;
&lt;li&gt;Dism++ - - &lt;a href=&#34;https://www.chuyu.me/&#34;&gt;https://www.chuyu.me/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;必备软件&#34;&gt;必备软件&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;7-zip  - - &lt;a href=&#34;http://www.7-zip.org/&#34;&gt;http://www.7-zip.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;坚果云  - - &lt;a href=&#34;https://www.jianguoyun.com&#34;&gt;https://www.jianguoyun.com&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;网速监控 NetSpeedMonitor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Enpass - - &lt;a href=&#34;https://www.enpass.io/&#34;&gt;https://www.enpass.io/&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;设置主密码，导入备份数据&lt;/li&gt;
&lt;li&gt;设置同步文件夹

&lt;ul&gt;
&lt;li&gt;D:\JianGuoYun&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;shadowsocks-windows - - &lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-windows/releases&#34;&gt;https://github.com/shadowsocks/shadowsocks-windows/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google Chrome  - - &lt;a href=&#34;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html&#34;&gt;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;登陆账号，同步插件及相关配置&lt;/li&gt;
&lt;li&gt;插件：Enpass、Flower Password、Humble New Tab Page、uBlock Origin、Octotree、Enhanced Steam、哔哩哔哩助手&lt;/li&gt;
&lt;li&gt;应用：Google Keep、Web Server for Chrome&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;效率工具&#34;&gt;效率工具&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;滴答清单 - - &lt;a href=&#34;https://www.dida365.com&#34;&gt;https://www.dida365.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MarkEditor - -  &lt;a href=&#34;http://zrey.com/app/markeditor&#34;&gt;http://zrey.com/app/markeditor&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;停止版本控制&lt;/li&gt;
&lt;li&gt;添加工作目录

&lt;ul&gt;
&lt;li&gt;D:\JianGuoYun\XIZERO&lt;/li&gt;
&lt;li&gt;D:\JianGuoYun\Tree hole&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Listary - -  &lt;a href=&#34;http://www.listary.com/&#34;&gt;http://www.listary.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;娱乐软件&#34;&gt;娱乐软件&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;网易云音乐 - -  &lt;a href=&#34;http://music.163.com/&#34;&gt;http://music.163.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Steam  - -  &lt;a href=&#34;http://store.steampowered.com/&#34;&gt;http://store.steampowered.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ASF - - &lt;a href=&#34;https://github.com/JustArchi/ArchiSteamFarm&#34;&gt;https://github.com/JustArchi/ArchiSteamFarm&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;wiki - - &lt;a href=&#34;http://steamcn.com/t187703-1-1&#34;&gt;http://steamcn.com/t187703-1-1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;扩展软件&#34;&gt;扩展软件&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;迅雷极速版&lt;/li&gt;
&lt;li&gt;SumatraPDF - - &lt;a href=&#34;https://www.sumatrapdfreader.org/free-pdf-reader-cn.html&#34;&gt;https://www.sumatrapdfreader.org/free-pdf-reader-cn.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Snipaste - - &lt;a href=&#34;https://zh.snipaste.com/&#34;&gt;https://zh.snipaste.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;备注-文件结构&#34;&gt;备注 - - 文件结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C - System&lt;/li&gt;
&lt;li&gt;D - Data

&lt;ul&gt;
&lt;li&gt;Project - Git 项目&lt;/li&gt;
&lt;li&gt;iProject - IDEA 项目&lt;/li&gt;
&lt;li&gt;m2 - Maven 本地仓库&lt;/li&gt;
&lt;li&gt;Software - 绿色软件&lt;/li&gt;
&lt;li&gt;CloudMusic - 网易云音乐本地&lt;/li&gt;
&lt;li&gt;Thunder - 迅雷下载&lt;/li&gt;
&lt;li&gt;JianGuoYun - 我的坚果云&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;E - Game&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>win10 系统重装手册</title>
      <link>https://www.xizero.com/tool/win10%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%89%8B%E5%86%8C/</link>
      <pubDate>Wed, 18 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/tool/win10%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%89%8B%E5%86%8C/</guid>
      <description>

&lt;h2 id=&#34;删除-github-上的-ssh-密钥&#34;&gt;删除 Github 上的 SSH 密钥&lt;/h2&gt;

&lt;p&gt;地址：&lt;a href=&#34;https://github.com/settings/keys&#34;&gt;https://github.com/settings/keys&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;删除-chrome-浏览器同步&#34;&gt;删除 Chrome 浏览器同步&lt;/h2&gt;

&lt;p&gt;地址：&lt;a href=&#34;https://www.google.com/settings/chrome/sync&#34;&gt;https://www.google.com/settings/chrome/sync&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java 多态</title>
      <link>https://www.xizero.com/java/Java-%E5%A4%9A%E6%80%81/</link>
      <pubDate>Sun, 08 Jan 2017 04:11:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/java/Java-%E5%A4%9A%E6%80%81/</guid>
      <description>

&lt;h1 id=&#34;多态&#34;&gt;多态&lt;/h1&gt;

&lt;p&gt;多态是同一个行为具有多个不同表现形式或形态的能力。&lt;/p&gt;

&lt;p&gt;方法的重写、重载与动态连接构成多态性&lt;/p&gt;

&lt;h2 id=&#34;条件&#34;&gt;条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;继承/实现&lt;/li&gt;
&lt;li&gt;方法的重写和重载&lt;/li&gt;
&lt;li&gt;父类引用指向子类实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;父类引用只能调用父类中定义的变量和方法，以及子类中重写的方法&lt;/p&gt;

&lt;p&gt;动态链接指：父类引用会调用子类实现重写或实现的方法&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java web 序言</title>
      <link>https://www.xizero.com/javaee/Java%20web%20%E5%BA%8F%E8%A8%80/</link>
      <pubDate>Fri, 06 Jan 2017 20:56:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/javaee/Java%20web%20%E5%BA%8F%E8%A8%80/</guid>
      <description>

&lt;h1 id=&#34;java-web-序言&#34;&gt;Java web 序言&lt;/h1&gt;

&lt;p&gt;不管怎样，学习越来越迷茫，每一步走地犹犹豫豫，忘记地越来越多，所以写一份总结。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Github Pages 配置 https</title>
      <link>https://www.xizero.com/note/Github%20Pages%20%E9%85%8D%E7%BD%AE%20https/</link>
      <pubDate>Fri, 06 Jan 2017 19:15:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/note/Github%20Pages%20%E9%85%8D%E7%BD%AE%20https/</guid>
      <description>

&lt;h1 id=&#34;github-pages-配置-https&#34;&gt;Github Pages 配置 https&lt;/h1&gt;

&lt;p&gt;Github Pages 不支持自定义域名https，虽然使用第三方的解析代理可以实现，但是却不稳定也并不知道什么时候失效，凡事要靠自己来。&lt;/p&gt;

&lt;p&gt;搜索查找，知道使用 &lt;strong&gt;Nginx 反向代理&lt;/strong&gt; 可以实现。&lt;/p&gt;

&lt;p&gt;下面是一些简单的笔记，需要一个ubuntu环境的云服务器，其他环境自行查找。&lt;/p&gt;

&lt;h2 id=&#34;安装-nginx&#34;&gt;安装 Nginx&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;apt-get install nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;域名解析&#34;&gt;域名解析&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;删除 Github Pages 上的 CNAME ，不使用自定义域名。&lt;/li&gt;
&lt;li&gt;在域名解析商那，将自定义域名用A解析到云服务器&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;申请证书&#34;&gt;申请证书&lt;/h2&gt;

&lt;p&gt;可以搜索 Let’s Encrypt&lt;/p&gt;

&lt;h2 id=&#34;nginx-配置&#34;&gt;Nginx 配置&lt;/h2&gt;

&lt;p&gt;如果默认安装，&lt;code&gt;/etc/nginx/conf.d&lt;/code&gt; 目录是自定义配置文件的存放的地方，新建一个 &lt;code&gt;.conf&lt;/code&gt; 文件，文件名随意。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;xxx.com 表示你的自定义域名&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;添加一个虚拟主机，监听 80 ，让 http 跳转到 https&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
        listen 80 ;
        server_name xxx.com;
        rewrite ^(.*)$  https://xxx.com$1 permanent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加一个虚拟主机，监听 443 ，&lt;code&gt;location /&lt;/code&gt; 设置反向代理 Github pages，&lt;code&gt;ssl_certificate&lt;/code&gt;等设置证书，最后的 &lt;code&gt;location&lt;/code&gt; 设置缓存时间。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;添加证书的时候，注意路径，使用 &lt;code&gt;nginx -t xxx.conf&lt;/code&gt; 查看配置文件是否错误，多看看日志&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;server {
        listen 443 ssl;
        server_name xxx.com;
        ssl on;
        ssl_certificate conf.d/xxx.com_bundle.crt;
        ssl_certificate_key conf.d/xxx.com.key;
        location / {
                proxy_pass https://xxx.github.io/;
                proxy_redirect     off;
                proxy_set_header   X-Real-IP  $remote_addr;
                proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        }
        location ~ /purge(/.*){
            expires 10m;
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行-nginx&#34;&gt;运行 nginx&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;service nginx start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://imciel.com/2016/05/09/github-pages-reverse-proxy-https/&#34;&gt;反向代理 GitHub Pages 并配置博客 HTTPS 访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://taozj.org/201603/blog-site-under-https.html#&#34;&gt;我的博客用上HTTPS啦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://echo.pm/lnmp-nginx-ssl-https&#34;&gt;在 Nginx（LNMP）上配置 NameCheap SSL 证书并开启强制 HTTPS 的方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/q/1010000006614489&#34;&gt;nginx ssl强制跳转&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Apache Tomcat</title>
      <link>https://www.xizero.com/javaee/Apache%20Tomcat/</link>
      <pubDate>Tue, 03 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/javaee/Apache%20Tomcat/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Http 协议</title>
      <link>https://www.xizero.com/javaee/Http%20%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 02 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/javaee/Http%20%E5%8D%8F%E8%AE%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java Servlet</title>
      <link>https://www.xizero.com/javaee/Java%20Servlet/</link>
      <pubDate>Sun, 01 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/javaee/Java%20Servlet/</guid>
      <description>

&lt;h1 id=&#34;java-servlet&#34;&gt;Java Servlet&lt;/h1&gt;

&lt;h2 id=&#34;什么是-java-servlet&#34;&gt;什么是 Java Servlet ?&lt;/h2&gt;

&lt;p&gt;维基百科：&lt;a href=&#34;https://zh.wikipedia.org/wiki/Java_Servlet&#34;&gt;https://zh.wikipedia.org/wiki/Java_Servlet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javaee/7/tutorial/servlets.htm#BNAFD&#34;&gt;Java Platform, Enterprise Edition: The Java EE Tutorial&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A servlet is a Java programming language class used to extend the capabilities of servers that host applications accessed by means of a request-response programming model.&lt;/p&gt;

&lt;p&gt;Java Servlet 是 Java 应用程序 ，运行在服务器端，由容器进行管理，生成动态内容。&lt;/p&gt;

&lt;p&gt;虽然 servlet 可以响应任何类型的请求，但通常用于web容器，Java Servlet 定义了对 Http 的特定 servlet 类。&lt;/p&gt;

&lt;p&gt;javax.servlet和javax.servlet.http包提供了用于编写servlet的接口和类。 所有servlet必须实现Servlet接口，它&lt;strong&gt;定义了生命周期方法&lt;/strong&gt;。 当实现通用服务时，可以使用或扩展Java Servlet API提供的GenericServlet类。 HttpServlet类提供了用于处理特定于HTTP的服务的方法，例如doGet和doPost。&lt;/p&gt;

&lt;h2 id=&#34;servlet-的生命周期&#34;&gt;Servlet 的生命周期&lt;/h2&gt;

&lt;p&gt;Servlet 的生命周期由 servlet 容器控制。&lt;/p&gt;

&lt;p&gt;当一个请求映射到servlet，容器执行&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果servlet的实例不存在，则web容器：

&lt;ul&gt;
&lt;li&gt;加载servlet类&lt;/li&gt;
&lt;li&gt;创建servlet类的实例&lt;/li&gt;
&lt;li&gt;通过调用初始化servlet实例&lt;strong&gt;init方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;容器调用&lt;strong&gt;service方法&lt;/strong&gt;，判断请求方式，传递请求和响应对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果需要删除该servlet，容器通过调用servlet的&lt;strong&gt;destroy方法&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;servlet-核心类&#34;&gt;Servlet 核心类&lt;/h2&gt;

&lt;p&gt;Java EE API : &lt;a href=&#34;https://docs.oracle.com/javaee/7/api/&#34;&gt;https://docs.oracle.com/javaee/7/api/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;

&lt;p&gt;使用注解 @WebServlet( &amp;ldquo;url &amp;rdquo; ) , url 是 servlet 的路径映射 ，必须是唯一的 ，使用该注解必须继承 HttpServlet&lt;/p&gt;

&lt;p&gt;也可以在 web.xml 中配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;

@WebServlet（“/ test”）
public class ModlServlet extends HttpServlet {
    ... ...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Apache Tomcat</title>
      <link>https://www.xizero.com/java/java-%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Tue, 13 Dec 2016 12:00:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/java/java-%E6%B3%9B%E5%9E%8B/</guid>
      <description>

&lt;h1 id=&#34;泛型&#34;&gt;泛型&lt;/h1&gt;

&lt;h2 id=&#34;泛型是什么&#34;&gt;泛型是什么?&lt;/h2&gt;

&lt;p&gt;泛型是一种编译器机制，在编写代码时&lt;strong&gt;参数化类型&lt;/strong&gt;，在实例化化时&lt;strong&gt;指定&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;泛型编程&#34;&gt;泛型编程&lt;/h2&gt;

&lt;h3 id=&#34;泛型类-容器类&#34;&gt;泛型类/容器类&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;泛型类中依然可以使用基本类型和引用类型，不一定都要参数化类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义一个泛型类&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在类名后使用 &amp;lt;&amp;gt; 定义一个参数化类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App&amp;lt;T&amp;gt; {
    private T x;

    public T getX() {
        return x;
    }

    public void setX(T x) {
        this.x = x;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例化泛型类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main{
    public static void main(String[] args) {
        
        //指定类型为 String
        App&amp;lt;String&amp;gt; app = new App&amp;lt;&amp;gt;();
        app.setX(&amp;quot;Hello World!&amp;quot;);
        System.out.println(app.getX()); //Hello World!

        //指定类型为 Integer
        App&amp;lt;Integer&amp;gt; app1 = new App&amp;lt;&amp;gt;();
        app1.setX(100);
        System.out.println(app1.getX()); // 100
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;实例化时指定的参数类型必须是类，不能是&lt;strong&gt;基本类型&lt;/strong&gt;，原因看 泛型的实现原理 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义一个有多个参数类型的泛型类&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在 &amp;lt;&amp;gt; 中可以定义多个参数化类型，之间用 , 隔开&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App1&amp;lt;T,U,B&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;App1&amp;lt;String,Integer,String&amp;gt; app1 = new App1&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个泛型抽象类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class App2&amp;lt;T&amp;gt; {
    private T y;

    public T getY() {
        return y;
    }

    public void setY(T y) {
        this.y = y;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继承抽象泛型类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App3 extends App2&amp;lt;String&amp;gt; {
    public static void main(String[] args) {
        App3 app3 = new App3();
        app3.setY(&amp;quot;泛型抽象类&amp;quot;);
        System.out.println(app3.getY());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;参数化类型的名称可以自定义，常用的有KTVE，具体含义看 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;泛型接口&#34;&gt;泛型接口&lt;/h3&gt;

&lt;p&gt;定义一个泛型接口&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;接口中参数化类型的定义和类的一样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IApp&amp;lt;T&amp;gt;{
    public T get();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接口继承泛型接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IApp1 extends IApp&amp;lt;String&amp;gt; {
    public String getAll();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;泛型接口实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public  class AppImpl implements IApp&amp;lt;String&amp;gt; {
    @Override
    public String get() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;泛型方法&#34;&gt;泛型方法&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;泛型方法不只可以泛型类、泛型接口中定义，&lt;strong&gt;普通类&lt;/strong&gt;中也可以&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义一个泛型方法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在普通方法中定义参数化类型，在访问修饰符之后，返回类型之前，使用 &amp;lt;&amp;gt; 定义。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用参数化类型定义参数的类型
public &amp;lt;T&amp;gt; void hello(T t){
    System.out.println(&amp;quot;Hello&amp;quot;+t);
}

//使用参数化类型定义返回类型
public &amp;lt;T&amp;gt; T hello2(){
    return null;
}

//一起使用
public &amp;lt;T&amp;gt; T hello3(T t){
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个静态的泛型方法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在静态泛型中定义参数化类型，在static 之后，返回类型之前&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; T world(T t){
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个可变参数的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; void out(T... args) {
    for (T t : args) {
        System.out.println(t);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用泛型方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//像普通的方法一样用
app.hello();
//指定参数化类型
app.&amp;lt;String&amp;gt;hello();
//静态方法也一样
App.world();
App.&amp;lt;String&amp;gt;world();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;泛型的继承&#34;&gt;泛型的继承&lt;/h2&gt;

&lt;h3 id=&#34;泛型类的继承&#34;&gt;泛型类的继承&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;类型参数是当前类定义的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//type parameter of App1
public class App1&amp;lt;T&amp;gt; extends App0&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;泛型类实现泛型接口&#34;&gt;泛型类实现泛型接口&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App&amp;lt;T&amp;gt; extends IApp&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;泛型接口继承泛型接口&#34;&gt;泛型接口继承泛型接口&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IApp1&amp;lt;T&amp;gt; extends IApp0&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通配符和上下界&#34;&gt;通配符和上下界&lt;/h2&gt;

&lt;h3 id=&#34;通配符&#34;&gt;通配符 ?&lt;/h3&gt;

&lt;p&gt;通配符 ? 表示未知类型，不确定类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;只是用来在实例化时填充&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//定义一个通用的容器类引用
App&amp;lt;?&amp;gt; app;

//指向不同对象
app = new App&amp;lt;String&amp;gt;();

app = new App&amp;lt;Integer&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;上下界&#34;&gt;上下界&lt;/h3&gt;

&lt;p&gt;关键字: extends super&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lt; ? extends T&amp;gt; : 声明上界，表示参数化的类型是 T 或 T 的子类型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lt; ? super T&amp;gt;：声明下界，表示参数的类型是 T 或 T 的父类型，直至 Object&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解通配符和上下界的三个方面
- 引用指向的实现对象是否在上下界范围内
- 添加元素时，注意类型是否确定，注意多态（父类引用指向子类实现对象）
- 返回值的类型&lt;/p&gt;

&lt;p&gt;**深入理解 &amp;lt; ? extends T&amp;gt; **&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
    static class A{};
    static class B extends A{};
    static class C extends B{};
    
    public static void main(String[] args) {
        List&amp;lt;? extends A&amp;gt; list = new ArrayList&amp;lt;B&amp;gt;();
        //编译器报错
        //list.add(new A());
        //list.add(new B());
        //list.add(new C());
        list.add(null);

        B b = list.get(0);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list 指向的是 A 或者 A 的子类型的ArrayList 对象&lt;/p&gt;

&lt;p&gt;list 不能添加非空元素，原因是 &lt;strong&gt;编译器无法确定List所持有的类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但可以取出时，值得类型是 A ，因为多态，父类引用指向子类实现。&lt;/p&gt;

&lt;p&gt;**深入理解 &amp;lt; ? super T&amp;gt; **&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
    static class A{};
    static class B extends A{};
    static class C extends B{};
    public static void main(String[] args) {
        List&amp;lt;? super B&amp;gt; list = new ArrayList&amp;lt;B&amp;gt;();
        //注释掉的编译错误
        //list.add(new A());
        list.add(new B());
        list.add(new Object());
        //list.add(null);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List&amp;lt; ? super B&amp;gt; list 可以指向是 B 或 B 的父类型的 ArrayList 对象&lt;/p&gt;

&lt;p&gt;但是可以添加的元素类型应该是 B 或 B 的子类型，可以添加原因也是多态&lt;/p&gt;

&lt;p&gt;从list中取值，返回的是 Object&lt;/p&gt;

&lt;h2 id=&#34;pecs原则&#34;&gt;PECS原则&lt;/h2&gt;

&lt;p&gt;如果要从集合中读取类型T的数据，并且&lt;strong&gt;不能写入&lt;/strong&gt;，可以使用 ? extends 通配符；(Producer Extends)&lt;/p&gt;

&lt;p&gt;如果要从集合中写入类型T的数据，并且&lt;strong&gt;不需要读取&lt;/strong&gt;，可以使用 ? super 通配符；(Consumer Super)&lt;/p&gt;

&lt;p&gt;如果既要存又要取，那么就不要使用任何通配符。&lt;/p&gt;

&lt;p&gt;出 处 ：&lt;a href=&#34;http://flyingcat2013.blog.51cto.com/7061638/1616068&#34;&gt;Java泛型中的PECS原则&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;和-t-的区别&#34;&gt;? 和 T 的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;? 用在&lt;strong&gt;实例&lt;/strong&gt;泛型时，填充范围。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;T 用在&lt;strong&gt;定义&lt;/strong&gt;泛型时，参数化类型。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;与上下界一起使用时，区别还是一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;泛型的实现原理&#34;&gt;泛型的实现原理&lt;/h2&gt;

&lt;p&gt;泛型的实现在编译阶段，通过&lt;strong&gt;类型擦除&lt;/strong&gt;实现&lt;/p&gt;

&lt;h3 id=&#34;type-erasure-http-docs-oracle-com-javase-tutorial-java-generics-erasure-html&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/java/generics/erasure.html&#34;&gt;Type Erasure&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming.&lt;/p&gt;

&lt;p&gt;Java 引入泛型，可以在编译时提供更严格的类型检查，并且支持泛型编程。&lt;/p&gt;

&lt;p&gt;To implement generics, the Java compiler applies type erasure to:&lt;/p&gt;

&lt;p&gt;为了实现泛型，java 编译器使用类型擦除 ：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.&lt;/li&gt;
&lt;li&gt;Insert type casts if necessary to preserve type safety.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate bridge methods to preserve polymorphism in extended generic types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将所有参数类型替换成其边界，如果没有边界替换成 Object 。因此，产生的字节码文件仅仅包含普通类、接口和方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;必要时添加类型转换以保存类型安全&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成桥方法以在扩展泛型时保持多态性&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.&lt;/p&gt;

&lt;p&gt;类型擦除确保不因为参数化类型而创建新类； 因此，泛型不会产生运行时开销。&lt;/p&gt;

&lt;h3 id=&#34;几种擦除&#34;&gt;几种擦除&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;T&gt;  &amp;ndash;&amp;gt; Object&lt;/li&gt;
&lt;li&gt;&amp;lt;? extends T&amp;gt; &amp;ndash;&amp;gt; T&lt;/li&gt;
&lt;li&gt;&amp;lt;? super T&amp;gt; &amp;ndash;&amp;gt; Object&lt;/li&gt;
&lt;li&gt;添加桥接方法，保证多态性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与之前的深入理解有关&lt;/p&gt;

&lt;h3 id=&#34;类型擦除的相关&#34;&gt;类型擦除的相关&lt;/h3&gt;

&lt;p&gt;1.类型擦除，在编译之前进行类型检查&lt;/p&gt;

&lt;p&gt;2.泛型与重载&lt;/p&gt;

&lt;p&gt;因为类型擦除，所以下面的两个方法的参数类型相同，会报错，both methods hava same erasure.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void a(List&amp;lt;Object&amp;gt; list){};
public void a(List&amp;lt;String&amp;gt; list){};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.泛型与多态&lt;/p&gt;

&lt;p&gt;会生成桥方法，以保证多态&lt;/p&gt;

&lt;p&gt;4.泛型与static&lt;/p&gt;

&lt;p&gt;类的参数化类型不能定义静态变量和方法。&lt;/p&gt;

&lt;p&gt;但是泛型方法可以定义成静态方法，它使用的自己的参数类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; T get( STring s){};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;泛型类的所有静态变量是共享的。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/sharewind/archive/2012/11/26/2788698.html&#34;&gt;Java泛型通配符extends与super&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/255&#34;&gt;Java泛型中extends和super的理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/226&#34;&gt;Java的类型擦除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/lonelyroamer/article/details/7868820&#34;&gt;java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>java 泛型 TKVE 含义</title>
      <link>https://www.xizero.com/java/java-%E6%B3%9B%E5%9E%8B-TKVE/</link>
      <pubDate>Thu, 24 Nov 2016 15:55:43 +0800</pubDate>
      
      <guid>https://www.xizero.com/java/java-%E6%B3%9B%E5%9E%8B-TKVE/</guid>
      <description>

&lt;h2 id=&#34;java-泛型经常使用的符号的含义&#34;&gt;Java 泛型经常使用的符号的含义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;T &amp;ndash; Type / java 类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;K &amp;ndash; Key / 键&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;V &amp;ndash; Value / 值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;E &amp;ndash; Element / 集合中的元素&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;? &amp;ndash; 通配符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;S、U、V &amp;ndash; 2nd、3rd、4th types&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;www.hollischuang.com/archives/252&#34;&gt;Java泛型中K T V E ？ object等的含义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java 序列化</title>
      <link>https://www.xizero.com/java/java-%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 23 Nov 2016 16:28:21 +0800</pubDate>
      
      <guid>https://www.xizero.com/java/java-%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>

&lt;h2 id=&#34;什么是序列化&#34;&gt;什么是序列化？&lt;/h2&gt;

&lt;p&gt;序列化是为了保存对象的状态，将对象的状态装换为字节数组，反序列化就是重构对象。&lt;/p&gt;

&lt;p&gt;就像是冰冻魔法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相关API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;java.io.Serializable&lt;/li&gt;
&lt;li&gt;java.io.Externalizable&lt;/li&gt;
&lt;li&gt;ObjectOutput&lt;/li&gt;
&lt;li&gt;ObjectInput&lt;/li&gt;
&lt;li&gt;ObjectOutputStream&lt;/li&gt;
&lt;li&gt;ObjectInputStream&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;怎么用&#34;&gt;怎么用？&lt;/h2&gt;

&lt;p&gt;只要一个类实现了 &lt;code&gt;java.io.Serializable&lt;/code&gt; 接口就能被序列化,该接口仅作为一个标识，标识这个类可以进行序列化。&lt;/p&gt;

&lt;p&gt;ObjectOutputStream.writeObject(Object); 将对象入输出流，序列化&lt;/p&gt;

&lt;p&gt;ObjectInputStream.readObject(); 从流中读取对象，反序列化&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;标识:在进行序列化时，在 writeObject() 中会检测 obj instanceof Serializable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;例&#34;&gt;例&lt;/h3&gt;

&lt;p&gt;序列化对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.Serializable;

public class Cat implements Serializable {
    private String name;
    private String age;
    private static final long serialVersionUID = 1L;
    public Cat() {
    }

    public Cat(String name, String age) {

        this.name = name;
        this.age = age;
    }

   //get() set()

    @Override
    public String toString() {
        return &amp;quot;Cat{&amp;quot; +
                &amp;quot;name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, age=&#39;&amp;quot; + age + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;序列化过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.x.model.Cat;

import java.io.*;

public class Main {

    public static void main(String[] args) {
        Cat cat = new Cat(&amp;quot;huang&amp;quot;,&amp;quot;5&amp;quot;);
        System.out.println(cat);



        try (FileOutputStream file = new FileOutputStream(&amp;quot;he&amp;quot;); ObjectOutputStream oos =  new ObjectOutputStream(file);){
            oos.writeObject(cat);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (FileInputStream file = new FileInputStream(&amp;quot;he&amp;quot;);ObjectInputStream ois = new ObjectInputStream(file)) {
            Cat cat1 = (Cat)ois.readObject();
            System.out.println(cat1);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用 Externalizable 接口，需要重写 writeExternal() 和 readExternal() ，可自定义序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化ID(private static final long serialVersionUID)不同，反序列化报java.io.InvalidClassException异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;静态变量不会序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 transient 关键字的变量不会序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化中继承&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;父类实现序列化，子类默认继承&lt;/li&gt;
&lt;li&gt;子类实现序列化，若父类变量也要保存则需要父类序列化；不需要父类序列化，反序列化时调用父类的无参构造函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/1150&#34;&gt;Java对象的序列化与反序列化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-5things1/&#34;&gt;关于 Java 对象序列化您不知道的 5 件事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-serial/&#34;&gt;Java 序列化的高级认识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>String 相关</title>
      <link>https://www.xizero.com/java/String%20%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Tue, 22 Nov 2016 08:36:39 +0800</pubDate>
      
      <guid>https://www.xizero.com/java/String%20%E7%9B%B8%E5%85%B3/</guid>
      <description>

&lt;h2 id=&#34;string-成员变量&#34;&gt;String 成员变量&lt;/h2&gt;

&lt;p&gt;String 是典型的&lt;a href=&#34;http://www.cnblogs.com/java-my-life/archive/2012/05/08/2487757.html&#34;&gt;不变模式设计&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/String.java?av=f&#34;&gt;JDK 8 源码地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/String.java?av=f&#34;&gt;JDK 6 源码地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
//JDK 1.8
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {
    //The value is used for character storage.
    private final char value[];

    //Cache the hash code for the string
    private int hash; // Default to 0
}

//JDK1.6
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence{
    //The value is used for character storage.
    private final char value[];

    //The offset is the first index of the storage that is used.
    private final int offset;

    //The count is the number of characters in the String.
    private final int count;

    //Cache the hash code for the string
    private int hash; // Default to 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常量池&#34;&gt;常量池&lt;/h2&gt;

&lt;p&gt;java编译时会生成常量池（Constant pool），保存字面常量和符号引用（类名、方法名、接口名和字段名等）。&lt;/p&gt;

&lt;h3 id=&#34;创建字符串对象&#34;&gt;创建字符串对象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;new 运算符&lt;/li&gt;
&lt;li&gt;字符串常量&lt;/li&gt;
&lt;li&gt;&amp;rdquo;+&amp;ldquo;连接的表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相同的字符串常量或结果相同的字符串常量表达式创建字符串对象时，
如果常量池中已经存在，相同序列的字符串，则该对象直接指向；不存在时，会在常量池创建一个新的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String a1 = &amp;quot;abc&amp;quot;;
String a2 = &amp;quot;abc&amp;quot;;
String a3 = &amp;quot;a&amp;quot;+&amp;quot;bc&amp;quot;;
System,out.println(a1==a2+&amp;quot;\t&amp;quot;+a2==a3); //true true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为字符串序列相同，指向的常量池中同一个字符串，所以为true。&lt;/p&gt;

&lt;p&gt;使用 new 创建字符串对象时，会在堆中创建一个新的String对象，并且该String对象的char value[]会指向常量池中的字符串，不存在则创建。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
String b1 = new String(&amp;quot;abc&amp;quot;);
String b2 = new String(&amp;quot;abc&amp;quot;);
System.out.println(b1==b2); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用new会在堆中创建新的对象,地址当然不同.&lt;/p&gt;

&lt;h3 id=&#34;string&#34;&gt;String +&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&amp;rdquo; &amp;ldquo;+[String] 或 [String]+[String]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;会在编译时,调用StringBuilder的append()和toString(),最终指向的是堆上新创建的String对象.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String c1 = &amp;quot;abc&amp;quot;;
String c2 = &amp;quot;123&amp;quot;+c1;
String c3 = &amp;quot;123abc&amp;quot;;
System.out.println(c2==c3); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;rdquo; &amp;ldquo;+&amp;rdquo; &amp;ldquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[final String]+[final String] 或 [final String]+&amp;rdquo; &amp;ldquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当final修饰的对象发生连接动作时，虚拟机会进行优化，将表达式结果直接赋值给目标变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final String a = &amp;quot;hello &amp;quot;;
final String b = &amp;quot;world&amp;quot;;
String c = a + &amp;quot;world&amp;quot;;
String d = &amp;quot;hello world&amp;quot;;
System.out.println(c==d); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string-intern&#34;&gt;String.intern()&lt;/h2&gt;

&lt;p&gt;是一个 Native 方法，调用 C++的 StringTable::intern&lt;/p&gt;

&lt;p&gt;如果常量池中已经存在该字符串，则返回池中的字符串；否则将此字符串添加到常量池中，并返回引用。&lt;/p&gt;

&lt;h2 id=&#34;string-substring&#34;&gt;String.substring()&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//JDK1.6
public String substring(int beginIndex) {
    return substring(beginIndex, count);
}
public String substring(int beginIndex, int endIndex) {
    if (beginIndex &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex &amp;gt; count) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (beginIndex &amp;gt; endIndex) {
        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);
    }
    return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == count)) ? this :
        new String(offset + beginIndex, endIndex - beginIndex, value);
}

String(int offset, int count, char value[]) {
    this.value = value;
    this.offset = offset;
    this.count = count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JDK1.6 中的实现只是调整了 offset 和 count ,使用的是共享的字符数组。&lt;/p&gt;

&lt;p&gt;当使用substring截取一个很长的字符串的2个字符时，会占用这个长字符串，不能垃圾回收。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//JDK 1.8
public String substring(int beginIndex) {
        if (beginIndex &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        int subLen = value.length - beginIndex;
        if (subLen &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}

public String substring(int beginIndex, int endIndex) {
        if (beginIndex &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        if (endIndex &amp;gt; value.length) {
            throw new StringIndexOutOfBoundsException(endIndex);
        }
        int subLen = endIndex - beginIndex;
        if (subLen &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);
}

public String(char value[], int offset, int count) {
        if (offset &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(offset);
        }
        if (count &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        // Note: offset or count might be near -1&amp;gt;&amp;gt;&amp;gt;1.
        if (offset &amp;gt; value.length - count) {
            throw new StringIndexOutOfBoundsException(offset + count);
        }
        this.value = Arrays.copyOfRange(value, offset, offset+count);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析一下 substring 源码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;报StringIndexOutOfBoundsException异常

&lt;ul&gt;
&lt;li&gt;beginIndex &amp;lt; 0&lt;/li&gt;
&lt;li&gt;endIndex &amp;gt; value.length&lt;/li&gt;
&lt;li&gt;subLen &amp;lt; 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;subLen 是新的字符串的长度&lt;/li&gt;
&lt;li&gt;endIndex的意义不明确

&lt;ul&gt;
&lt;li&gt;理解为 beginIndex + subLen&lt;/li&gt;
&lt;li&gt;beginIndex &amp;lt;= endIndex &amp;lt;= value.length&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当截取范围与原字符串相同返回this，否则 new 一个新的String对象,在构造方法中复制生成了新的 value。&lt;/li&gt;
&lt;li&gt;substring(1,1)

&lt;ul&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;==s.substring(1,1) //true&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;.equals(s.substring(1,1)) //false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过反射机制可以对String进行修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;== 和 equals()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;== 比较引用是否指向堆内存中的同一个String对象&lt;/li&gt;
&lt;li&gt;equals() 比较的是字符串的内容是否相同&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String StringBuilder StringBuffer 区别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;String是不可变(final)类，每次在String对象上的操作都会生成一个新的对象；&lt;/li&gt;
&lt;li&gt;StringBuffer和StringBuilder是可变的，它允许在原来对象上进行操作，而不用每次增加对象；&lt;/li&gt;
&lt;li&gt;StringBuffer是线程安全的，但效率较低，而StringBuilder则不是线程安全的，效率最高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/21711.html&#34;&gt;浅谈Java String内幕（上）&lt;/a&gt; &amp;ndash; javap 查看字节码&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/99&#34;&gt;Java 7 源码学习系列（一）——String&lt;/a&gt; &amp;ndash; 看源码解释&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://brokendreams.iteye.com/blog/2260870&#34;&gt;关于Java String的一些总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一个想法</title>
      <link>https://www.xizero.com/zero/%E4%B8%80%E4%B8%AA%E6%83%B3%E6%B3%95/</link>
      <pubDate>Sun, 20 Nov 2016 12:19:55 +0800</pubDate>
      
      <guid>https://www.xizero.com/zero/%E4%B8%80%E4%B8%AA%E6%83%B3%E6%B3%95/</guid>
      <description>&lt;p&gt;自己做了一个小东西，一个简单的 &lt;a href=&#34;http://hao.xizero.com&#34;&gt;网址索引&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;因为要显示每个网站的favicon，google一下，找到了一些还能用公共的api。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;google：&lt;a href=&#34;http://www.google.com/s2/favicons?domain=&#34;&gt;http://www.google.com/s2/favicons?domain=&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BYI_API：&lt;a href=&#34;https://api.byi.pw/favicon/&#34;&gt;https://api.byi.pw/favicon/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他的都不能用了，谷歌还要翻墙，最后就用了BYI_API。&lt;/p&gt;

&lt;p&gt;一直都挺好的，被墙的网站也能返回，直到前几天（估计在11月12日左右），崩了（&amp;gt;_&amp;lt;）。&lt;/p&gt;

&lt;p&gt;面对满页的XX，我换了另一个。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://f.ydr.me/?url=&#34;&gt;http://f.ydr.me/?url=&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是，满页的ie图标是要干啥（不支持的被墙的网站）&lt;/p&gt;

&lt;p&gt;后来，看到了一个问答，大概是通过判断图片的MD5来判断是不是小地球（获取失败时返回），我灵感一动，两天的折磨……&lt;/p&gt;

&lt;p&gt;前段框架用的是刚学的vue.js 2，用过滤器 filters 不就可以了吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
{{data_url  | filter}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要我把前面的链接获取到，然后判断那个图标是不是小地球，再来调用其他的api，不就可以了吗。&lt;/p&gt;

&lt;p&gt;但是 vue 不支持在绑定属性中使用过滤器，（&amp;gt;_&amp;lt;），好，再google，(⊙o⊙)哦，要用计算属性 computed 啊！？&lt;/p&gt;

&lt;p&gt;但是计算属性不能传参，（&amp;gt;_&amp;lt;），好，只能再找了，可以用 methods 。&lt;/p&gt;

&lt;p&gt;之前学习了fetch，用fetch下图标，然后直接返回图片，这儿遇到点问题，主要是图片的处理和到最后也没有解决的跨域问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
fetch(img_url)
.then(function(res){
    return res.blob();
})
.then(function(imageBlob){
    img_src = window.URL.createObjectURL(imageBlob);
    //more
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个简单的fetch获取图片的例子，复刻官网上的，本地图片可以加载。&lt;/p&gt;

&lt;p&gt;但是favicon api是不支持跨域请求，所以一直在做挣扎。&lt;/p&gt;

&lt;p&gt;在这段时间之中，把这个方法放到了mounted，想让图片直接在加载时判断。&lt;/p&gt;

&lt;p&gt;主要是因为好好的看了一下js的闭包，之前有过卡在这儿的经历，还好征服了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
for(var i=0;i&amp;lt;json.length;i++){
    (function(i){
        for(var j=0;j&amp;lt;json[i].list.length;j++){
            (function(j){
                fetch(
                &#39;https://s2.googleusercontent.com/s2/favicons?domain=&#39;
                +json[i].list[j].url,
                    {
                        mode:&amp;quot;cors&amp;quot;,
                        headers:{
                        &#39;Access-Control-Allow-Origin&#39;:&#39;*&#39;
                        }
                    }
                )
                .then(function(res){
                    return res.blob();
                })
                .then(function(imageBlob){
                    json[i].list[j].img
                    =window.URL.createObjectURL(imageBlob);
                })
            })(j);
        }
    })(i);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;痛苦的是解决fetch 的跨域问题&lt;/p&gt;

&lt;p&gt;fetch 的response 中有个mode的属性，可取值4个，包括 cors、no-cors等。&lt;/p&gt;

&lt;p&gt;默认为cors，但在请求图片时，浏览器会提醒跨域问题。
当设置为 no-cors 时， 虽然不会报错，但是你并不能获取resquest 中的data，所以然并软。&lt;/p&gt;

&lt;p&gt;还曾引入过fetch-jsonp.js，但是就像no-cors，获取不到内容。&lt;/p&gt;

&lt;p&gt;设置请求头中的Access-Control-Allow-Origin，会提示服务器不支持。&lt;/p&gt;

&lt;p&gt;就当我要放弃时，我又突发奇想，等网页加载完，判断下载本地的图片。&lt;/p&gt;

&lt;p&gt;不能直接获取图片的MD5，找到了别人写的代码，先变成Base64.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getBase64Image(img) {
    var canvas = document.createElement(&amp;quot;canvas&amp;quot;);
    canvas.width = img.width;
    canvas.height = img.height;

    var ctx = canvas.getContext(&amp;quot;2d&amp;quot;);
    ctx.drawImage(img, 0, 0, img.width, img.height);

    var dataURL = canvas.toDataURL(&amp;quot;image/png&amp;quot;);
    return dataURL

    // return dataURL.replace(&amp;quot;data:image/png;base64,&amp;quot;, &amp;quot;&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，用SparkMD5，讲Base64编码，再比较。&lt;/p&gt;

&lt;p&gt;小心翼翼地试了下，好像可以。&lt;/p&gt;

&lt;p&gt;但是，当我写好了代码，请求时，浏览器报错传到函数里面的不是一个HTMLElement。
我想是不是因为图片还没有加载完成，获取不到节点，那就判断一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
if (img.complete) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，&lt;strong&gt;canvas&lt;/strong&gt; 不支持跨域 ！&lt;/p&gt;

&lt;p&gt;所以，我放弃了。&lt;/p&gt;

&lt;p&gt;我又重新看了一下开始的API，好像能用了，那就切换回来好了。&lt;/p&gt;

&lt;p&gt;看到他的代码开源，想要自己整一个,以防万一。&lt;/p&gt;

&lt;p&gt;（&amp;gt;_&amp;lt;）为什么是 拍X片 PHP ？？？&lt;/p&gt;

&lt;p&gt;结束&lt;/p&gt;

&lt;p&gt;后记&lt;/p&gt;

&lt;p&gt;当我兴致勃勃的去用java写一个api时，我卡在了线程同步……&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://www.xizero.com/about/</link>
      <pubDate>Sat, 19 Nov 2016 19:22:33 +0800</pubDate>
      
      <guid>https://www.xizero.com/about/</guid>
      <description>

&lt;h1 id=&#34;2017-1月2日&#34;&gt;2017 1月2日  🌤&lt;/h1&gt;

&lt;p&gt;元旦放假这几天，重新修改了主题，做了一些变化&lt;/p&gt;

&lt;p&gt;调整了网站的结构，分类归档&lt;/p&gt;

&lt;p&gt;今年，充满挑战和机遇，我应该怎么做？&lt;/p&gt;

&lt;h1 id=&#34;2016-11月19日&#34;&gt;2016 11月19日 🐳&lt;/h1&gt;

&lt;p&gt;早晨来了一场大雪，或许在深夜便开始了。&lt;/p&gt;

&lt;p&gt;这两天，学着别人的模板主题，自己拙略地仿写了一个，虽然粗糙，但毕竟费了一番心血。&lt;/p&gt;

&lt;p&gt;现在的我，没有什么。&lt;/p&gt;

&lt;p&gt;轨迹也是这个时代的缩影，随着人潮和催促而蹉跎。&lt;/p&gt;

&lt;p&gt;这个网站是个开始。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>