<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XIZERO</title>
    <link>http://f12998765.github.io/index.xml</link>
    <description>Recent content on XIZERO</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 10 Dec 2016 19:24:50 +0800</lastBuildDate>
    <atom:link href="http://f12998765.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux下的目录是干什么的</title>
      <link>http://f12998765.github.io/notes/Linux%E4%B8%8B%E7%9A%84%E7%9B%AE%E5%BD%95%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/</link>
      <pubDate>Sat, 10 Dec 2016 19:24:50 +0800</pubDate>
      
      <guid>http://f12998765.github.io/notes/Linux%E4%B8%8B%E7%9A%84%E7%9B%AE%E5%BD%95%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;/&lt;/h1&gt;

&lt;h2 id=&#34;根目录&#34;&gt;根目录&lt;/h2&gt;

&lt;h1 id=&#34;root&#34;&gt;/root&lt;/h1&gt;

&lt;h2 id=&#34;超级用户的目录&#34;&gt;超级用户的目录&lt;/h2&gt;

&lt;h1 id=&#34;boot&#34;&gt;/boot&lt;/h1&gt;

&lt;h2 id=&#34;系统启动文件&#34;&gt;系统启动文件&lt;/h2&gt;

&lt;h1 id=&#34;bin&#34;&gt;/bin&lt;/h1&gt;

&lt;h2 id=&#34;存放系统程序-默认指令程序&#34;&gt;存放系统程序，默认指令程序&lt;/h2&gt;

&lt;h1 id=&#34;etc&#34;&gt;/etc&lt;/h1&gt;

&lt;h2 id=&#34;存放系统配置文件&#34;&gt;存放系统配置文件&lt;/h2&gt;

&lt;h1 id=&#34;dev&#34;&gt;/dev&lt;/h1&gt;

&lt;h2 id=&#34;存放与外设有关的文件和驱动&#34;&gt;存放与外设有关的文件和驱动&lt;/h2&gt;

&lt;h1 id=&#34;home&#34;&gt;/home&lt;/h1&gt;

&lt;h2 id=&#34;存放用户数据&#34;&gt;存放用户数据&lt;/h2&gt;

&lt;h1 id=&#34;tmp&#34;&gt;/tmp&lt;/h1&gt;

&lt;h2 id=&#34;临时目录&#34;&gt;临时目录&lt;/h2&gt;

&lt;h1 id=&#34;usr&#34;&gt;/usr&lt;/h1&gt;

&lt;h2 id=&#34;存放非系统软件-例如游戏-开发工具等&#34;&gt;存放非系统软件，例如游戏、开发工具等&lt;/h2&gt;

&lt;h1 id=&#34;opt&#34;&gt;/opt&lt;/h1&gt;

&lt;h2 id=&#34;存放非正式程序&#34;&gt;存放非正式程序&lt;/h2&gt;

&lt;h1 id=&#34;usr-local&#34;&gt;usr/local&lt;/h1&gt;

&lt;h2 id=&#34;存放手动安装软件&#34;&gt;存放手动安装软件&lt;/h2&gt;

&lt;h1 id=&#34;media&#34;&gt;/media&lt;/h1&gt;

&lt;h2 id=&#34;挂载外部存储&#34;&gt;挂载外部存储&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>在Centos7中安装 PPTP VPN</title>
      <link>http://f12998765.github.io/notes/pptp/</link>
      <pubDate>Mon, 05 Dec 2016 19:56:31 +0800</pubDate>
      
      <guid>http://f12998765.github.io/notes/pptp/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;这篇文章只是简单的记录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;安装软件&#34;&gt;安装软件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yum install ppp pptpd
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置pptp&#34;&gt;配置PPTP&lt;/h2&gt;

&lt;h3 id=&#34;etc-pptpd-conf&#34;&gt;/etc/pptpd.conf&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /etc/pptpd.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找localip和remoteip，去掉前面的注释“#”，结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;localip 192.168.0.1
remoteip 192.168.0.234-238,192.168.0.245
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;etc-ppp-options-pptpd&#34;&gt;/etc/ppp/options/pptpd&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /etc/ppp/options/pptpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找”ms-dns”,去掉注释”#”,结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ms-dns 8.8.8.8
ms-dns 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;etc-ppp-chap-secrets&#34;&gt;/etc/ppp/chap-secrets&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /etc/ppp/chap-secrets
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加连接账户,格式如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用户名 pptpd 密码 *
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;etc-sysctl-conf&#34;&gt;/etc/sysctl.conf&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /etc/sysctl.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在最后添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.ipv4.ip_forward=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终端运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sysctl -p
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置firewalld&#34;&gt;配置Firewalld&lt;/h2&gt;

&lt;p&gt;启动 Firewalld&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl start  firewalld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -i eth0 -p tcp --dport 1723 -j ACCEPT
firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 0 -p gre -j ACCEPT
firewall-cmd --permanent --direct --add-rule ipv4 filter POSTROUTING 0 -t nat -o eth0 -j MASQUERADE
firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -i ppp+ -o eth0 -j ACCEPT
firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -i eth0 -o ppp+ -j ACCEPT
firewall-cmd --reload
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;启动pptp&#34;&gt;启动PPTP&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#启动
systemctl start pptpd

#重启
systemctl restart pptpd
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.wanghailin.cn/centos-7-vpn/&#34;&gt;Centos 7搭建VPN（PPTP）服务器方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lightning-ashe.com/develop/setup-pptp-server-on-centos/&#34;&gt;Setup PPTP Server on CentOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://feiio.com/2016/05/15/CentOS7-0%E6%90%AD%E5%BB%BAVPN-PPTP-%E6%9C%8D%E5%8A%A1%E5%99%A8/&#34;&gt;CentOS7.0搭建VPN(PPTP)服务器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>个人知识管理</title>
      <link>http://f12998765.github.io/xi/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 02 Dec 2016 14:46:03 +0800</pubDate>
      
      <guid>http://f12998765.github.io/xi/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/</guid>
      <description>

&lt;h2 id=&#34;personal-knowledge-management&#34;&gt;Personal Knowledge Management&lt;/h2&gt;

&lt;p&gt;个人知识管理，收集、整理、学习、创造、分享.&lt;/p&gt;

&lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;

&lt;h3 id=&#34;记录想法-锤子便签-https-cloud-smartisan-com-notes&#34;&gt;记录想法 - &lt;a href=&#34;https://cloud.smartisan.com/#/notes&#34;&gt;锤子便签&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;学习笔记-atom-https-atom-io&#34;&gt;学习笔记 - &lt;a href=&#34;https://atom.io/&#34;&gt;Atom&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;代码片段-gistbox-https-app-gistboxapp-com-library-my-gists&#34;&gt;代码片段 - &lt;a href=&#34;https://app.gistboxapp.com/library/my-gists&#34;&gt;GistBox&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;备份恢复-dropbox-https-www-dropbox-com-home&#34;&gt;备份恢复 - &lt;a href=&#34;https://www.dropbox.com/home&#34;&gt;Dropbox&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;静态博客-hugo-http-gohugo-io&#34;&gt;静态博客 - &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>java 泛型 TKVE 含义</title>
      <link>http://f12998765.github.io/java-notes/java-%E6%B3%9B%E5%9E%8B-TKVE/</link>
      <pubDate>Thu, 24 Nov 2016 15:55:43 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/java-%E6%B3%9B%E5%9E%8B-TKVE/</guid>
      <description>

&lt;h2 id=&#34;java-泛型经常使用的符号的含义&#34;&gt;Java 泛型经常使用的符号的含义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;T &amp;ndash; Type / java 类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;K &amp;ndash; Key / 键&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;V &amp;ndash; Value / 值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;E &amp;ndash; Element / 集合中的元素&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;? &amp;ndash; 通配符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;S、U、V &amp;ndash; 2nd、3rd、4th types&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;www.hollischuang.com/archives/252&#34;&gt;Java泛型中K T V E ？ object等的含义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java 序列化</title>
      <link>http://f12998765.github.io/java-notes/java%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 23 Nov 2016 16:28:21 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/java%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>

&lt;h2 id=&#34;什么是序列化&#34;&gt;什么是序列化？&lt;/h2&gt;

&lt;p&gt;序列化是为了保存对象的状态，将对象的状态装换为字节数组，反序列化就是重构对象。&lt;/p&gt;

&lt;p&gt;就像是冰冻魔法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相关API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;java.io.Serializable&lt;/li&gt;
&lt;li&gt;java.io.Externalizable&lt;/li&gt;
&lt;li&gt;ObjectOutput&lt;/li&gt;
&lt;li&gt;ObjectInput&lt;/li&gt;
&lt;li&gt;ObjectOutputStream&lt;/li&gt;
&lt;li&gt;ObjectInputStream&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;怎么用&#34;&gt;怎么用？&lt;/h2&gt;

&lt;p&gt;只要一个类实现了 &lt;code&gt;java.io.Serializable&lt;/code&gt; 接口就能被序列化,该接口仅作为一个标识，标识这个类可以进行序列化。&lt;/p&gt;

&lt;p&gt;ObjectOutputStream.writeObject(Object); 将对象入输出流，序列化&lt;/p&gt;

&lt;p&gt;ObjectInputStream.readObject(); 从流中读取对象，反序列化&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;标识:在进行序列化时，在 writeObject() 中会检测 obj instanceof Serializable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;例&#34;&gt;例&lt;/h3&gt;

&lt;p&gt;序列化对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.Serializable;

public class Cat implements Serializable {
    private String name;
    private String age;
    private static final long serialVersionUID = 1L;
    public Cat() {
    }

    public Cat(String name, String age) {

        this.name = name;
        this.age = age;
    }

   //get() set()

    @Override
    public String toString() {
        return &amp;quot;Cat{&amp;quot; +
                &amp;quot;name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, age=&#39;&amp;quot; + age + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;序列化过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.x.model.Cat;

import java.io.*;

public class Main {

    public static void main(String[] args) {
        Cat cat = new Cat(&amp;quot;huang&amp;quot;,&amp;quot;5&amp;quot;);
        System.out.println(cat);



        try (FileOutputStream file = new FileOutputStream(&amp;quot;he&amp;quot;); ObjectOutputStream oos =  new ObjectOutputStream(file);){
            oos.writeObject(cat);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (FileInputStream file = new FileInputStream(&amp;quot;he&amp;quot;);ObjectInputStream ois = new ObjectInputStream(file)) {
            Cat cat1 = (Cat)ois.readObject();
            System.out.println(cat1);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用 Externalizable 接口，需要重写 writeExternal() 和 readExternal() ，可自定义序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化ID(private static final long serialVersionUID)不同，反序列化报java.io.InvalidClassException异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;静态变量不会序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 transient 关键字的变量不会序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化中继承&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;父类实现序列化，子类默认继承&lt;/li&gt;
&lt;li&gt;子类实现序列化，若父类变量也要保存则需要父类序列化；不需要父类序列化，反序列化时调用父类的无参构造函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/1150&#34;&gt;Java对象的序列化与反序列化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-5things1/&#34;&gt;关于 Java 对象序列化您不知道的 5 件事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-serial/&#34;&gt;Java 序列化的高级认识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>String相关</title>
      <link>http://f12998765.github.io/java-notes/String%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Tue, 22 Nov 2016 08:36:39 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/String%E7%9B%B8%E5%85%B3/</guid>
      <description>

&lt;h2 id=&#34;string-成员变量&#34;&gt;String 成员变量&lt;/h2&gt;

&lt;p&gt;String 是典型的&lt;a href=&#34;http://www.cnblogs.com/java-my-life/archive/2012/05/08/2487757.html&#34;&gt;不变模式设计&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/String.java?av=f&#34;&gt;JDK 8 源码地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/String.java?av=f&#34;&gt;JDK 6 源码地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
//JDK 1.8
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {
	//The value is used for character storage.
	private final char value[];

	//Cache the hash code for the string
	private int hash; // Default to 0
}

//JDK1.6
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence{
	//The value is used for character storage.
	private final char value[];

	//The offset is the first index of the storage that is used.
	private final int offset;

	//The count is the number of characters in the String.
	private final int count;

	//Cache the hash code for the string
	private int hash; // Default to 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常量池&#34;&gt;常量池&lt;/h2&gt;

&lt;p&gt;java编译时会生成常量池（Constant pool），保存字面常量和符号引用（类名、方法名、接口名和字段名等）。&lt;/p&gt;

&lt;h3 id=&#34;创建字符串对象&#34;&gt;创建字符串对象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;new 运算符&lt;/li&gt;
&lt;li&gt;字符串常量&lt;/li&gt;
&lt;li&gt;&amp;rdquo;+&amp;ldquo;连接的表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相同的字符串常量或结果相同的字符串常量表达式创建字符串对象时，
如果常量池中已经存在，相同序列的字符串，则该对象直接指向；不存在时，会在常量池创建一个新的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String a1 = &amp;quot;abc&amp;quot;;
String a2 = &amp;quot;abc&amp;quot;;
String a3 = &amp;quot;a&amp;quot;+&amp;quot;bc&amp;quot;;
System,out.println(a1==a2+&amp;quot;\t&amp;quot;+a2==a3); //true true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为字符串序列相同，指向的常量池中同一个字符串，所以为true。&lt;/p&gt;

&lt;p&gt;使用 new 创建字符串对象时，会在堆中创建一个新的String对象，并且该String对象的char value[]会指向常量池中的字符串，不存在则创建。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
String b1 = new String(&amp;quot;abc&amp;quot;);
String b2 = new String(&amp;quot;abc&amp;quot;);
System.out.println(b1==b2); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用new会在堆中创建新的对象,地址当然不同.&lt;/p&gt;

&lt;h3 id=&#34;string&#34;&gt;String +&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&amp;rdquo; &amp;ldquo;+[String] 或 [String]+[String]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;会在编译时,调用StringBuilder的append()和toString(),最终指向的是堆上新创建的String对象.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String c1 = &amp;quot;abc&amp;quot;;
String c2 = &amp;quot;123&amp;quot;+c1;
String c3 = &amp;quot;123abc&amp;quot;;
System.out.println(c2==c3); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;rdquo; &amp;ldquo;+&amp;rdquo; &amp;ldquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[final String]+[final String] 或 [final String]+&amp;rdquo; &amp;ldquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当final修饰的对象发生连接动作时，虚拟机会进行优化，将表达式结果直接赋值给目标变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final String a = &amp;quot;hello &amp;quot;;
final String b = &amp;quot;world&amp;quot;;
String c = a + &amp;quot;world&amp;quot;;
String d = &amp;quot;hello world&amp;quot;;
System.out.println(c==d); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string-intern&#34;&gt;String.intern()&lt;/h2&gt;

&lt;p&gt;是一个 Native 方法，调用 C++的 StringTable::intern&lt;/p&gt;

&lt;p&gt;如果常量池中已经存在该字符串，则返回池中的字符串；否则将此字符串添加到常量池中，并返回引用。&lt;/p&gt;

&lt;h2 id=&#34;string-substring&#34;&gt;String.substring()&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//JDK1.6
public String substring(int beginIndex) {
	return substring(beginIndex, count);
}
public String substring(int beginIndex, int endIndex) {
	if (beginIndex &amp;lt; 0) {
		throw new StringIndexOutOfBoundsException(beginIndex);
	}
	if (endIndex &amp;gt; count) {
		throw new StringIndexOutOfBoundsException(endIndex);
	}
	if (beginIndex &amp;gt; endIndex) {
		throw new StringIndexOutOfBoundsException(endIndex - beginIndex);
	}
	return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == count)) ? this :
		new String(offset + beginIndex, endIndex - beginIndex, value);
}

String(int offset, int count, char value[]) {
	this.value = value;
	this.offset = offset;
	this.count = count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JDK1.6 中的实现只是调整了 offset 和 count ,使用的是共享的字符数组。&lt;/p&gt;

&lt;p&gt;当使用substring截取一个很长的字符串的2个字符时，会占用这个长字符串，不能垃圾回收。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//JDK 1.8
public String substring(int beginIndex) {
        if (beginIndex &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        int subLen = value.length - beginIndex;
		if (subLen &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}

public String substring(int beginIndex, int endIndex) {
		if (beginIndex &amp;lt; 0) {
			throw new StringIndexOutOfBoundsException(beginIndex);
		}
		if (endIndex &amp;gt; value.length) {
			throw new StringIndexOutOfBoundsException(endIndex);
		}
		int subLen = endIndex - beginIndex;
		if (subLen &amp;lt; 0) {
			throw new StringIndexOutOfBoundsException(subLen);
		}
		return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);
}

public String(char value[], int offset, int count) {
		if (offset &amp;lt; 0) {
			throw new StringIndexOutOfBoundsException(offset);
		}
		if (count &amp;lt; 0) {
			throw new StringIndexOutOfBoundsException(count);
		}
		// Note: offset or count might be near -1&amp;gt;&amp;gt;&amp;gt;1.
		if (offset &amp;gt; value.length - count) {
			throw new StringIndexOutOfBoundsException(offset + count);
		}
		this.value = Arrays.copyOfRange(value, offset, offset+count);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析一下 substring 源码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;报StringIndexOutOfBoundsException异常

&lt;ul&gt;
&lt;li&gt;beginIndex &amp;lt; 0&lt;/li&gt;
&lt;li&gt;endIndex &amp;gt; value.length&lt;/li&gt;
&lt;li&gt;subLen &amp;lt; 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;subLen 是新的字符串的长度&lt;/li&gt;
&lt;li&gt;endIndex的意义不明确

&lt;ul&gt;
&lt;li&gt;理解为 beginIndex + subLen&lt;/li&gt;
&lt;li&gt;beginIndex &amp;lt;= endIndex &amp;lt;= value.length&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当截取范围与原字符串相同返回this，否则 new 一个新的String对象,在构造方法中复制生成了新的 value。&lt;/li&gt;
&lt;li&gt;substring(1,1)

&lt;ul&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;==s.substring(1,1) //true&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;.equals(s.substring(1,1)) //false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过反射机制可以对String进行修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;== 和 equals()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;== 比较引用是否指向堆内存中的同一个String对象&lt;/li&gt;
&lt;li&gt;equals() 比较的是字符串的内容是否相同&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String StringBuilder StringBuffer 区别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;String是不可变(final)类，每次在String对象上的操作都会生成一个新的对象；&lt;/li&gt;
&lt;li&gt;StringBuffer和StringBuilder是可变的，它允许在原来对象上进行操作，而不用每次增加对象；&lt;/li&gt;
&lt;li&gt;StringBuffer是线程安全的，但效率较低，而StringBuilder则不是线程安全的，效率最高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/21711.html&#34;&gt;浅谈Java String内幕（上）&lt;/a&gt; &amp;ndash; javap 查看字节码&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/99&#34;&gt;Java 7 源码学习系列（一）——String&lt;/a&gt; &amp;ndash; 看源码解释&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://brokendreams.iteye.com/blog/2260870&#34;&gt;关于Java String的一些总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>java更新日志</title>
      <link>http://f12998765.github.io/java-notes/java%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 21 Nov 2016 20:12:08 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/java%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;java 笔记从 2016 暑假开始，到 10月完成第一稿，因为自己还是个初学者，还有很多的不足和错误，也有因为不懂而未完成的部分，总体上是把自己的知识梳理了一下。&lt;/p&gt;

&lt;p&gt;初次尝试写博客，现在看来这些更像是一些知识笔记，课本摘抄。&lt;/p&gt;

&lt;h2 id=&#34;更新-１-java工程师成神之路-http-www-hollischuang-com-archives-1001&#34;&gt;更新＃１　－－　&lt;a href=&#34;http://www.hollischuang.com/archives/1001&#34;&gt;Java工程师成神之路&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;2016-11-21&lt;/p&gt;

&lt;p&gt;今天思索了一个下午，明白自己必须从小目标开始。&lt;/p&gt;

&lt;p&gt;跟着别人走一段路，不至于那么迷茫，绕不出来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于未来 2016/11</title>
      <link>http://f12998765.github.io/xi/go/</link>
      <pubDate>Mon, 21 Nov 2016 08:39:53 +0800</pubDate>
      
      <guid>http://f12998765.github.io/xi/go/</guid>
      <description>&lt;p&gt;11月21日 2016 :cloud:&lt;/p&gt;

&lt;p&gt;这几周一直在迷茫，明知自己没有多少东西，但还是提不起劲来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“意识到了自己没有办法成为 top 1% 的程序员，还应该选择程序员的道路么？”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看到这句话的时候，的确很震惊，这不就是我的未来吗？&lt;/p&gt;

&lt;p&gt;从二流的大学生成为二流的程序员……&lt;/p&gt;

&lt;p&gt;瞬间秒杀掉了我所有的希望。&lt;/p&gt;

&lt;p&gt;可是，没有人天生就是 NO1 ，你为什么不能成为那个 top 1%?&lt;/p&gt;

&lt;p&gt;平地起高台，万事从头来。&lt;/p&gt;

&lt;p&gt;你需要是一个一个的小目标，在不经意间你就会发现，原来那个遥不可及的目标已经没那么困难了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我的小目标：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;总结整理 java web 基础&lt;/li&gt;
&lt;li&gt;总结整理 java web 框架&lt;/li&gt;
&lt;li&gt;学习计算机网络&lt;/li&gt;
&lt;li&gt;学习操作系统&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一个年前的目标&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;阅读 Spring 源码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一个遥不可及的目标&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在硅谷工作&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一个想法</title>
      <link>http://f12998765.github.io/xi/%E4%B8%80%E4%B8%AA%E6%83%B3%E6%B3%95/</link>
      <pubDate>Sun, 20 Nov 2016 12:19:55 +0800</pubDate>
      
      <guid>http://f12998765.github.io/xi/%E4%B8%80%E4%B8%AA%E6%83%B3%E6%B3%95/</guid>
      <description>&lt;p&gt;自己做了一个小东西，一个简单的 &lt;a href=&#34;http://hao.xizero.com&#34;&gt;网址索引&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;因为要显示每个网站的favicon，google一下，找到了一些还能用公共的api。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;google：&lt;a href=&#34;http://www.google.com/s2/favicons?domain=&#34;&gt;http://www.google.com/s2/favicons?domain=&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BYI_API：&lt;a href=&#34;https://api.byi.pw/favicon/&#34;&gt;https://api.byi.pw/favicon/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他的都不能用了，谷歌还要翻墙，最后就用了BYI_API。&lt;/p&gt;

&lt;p&gt;一直都挺好的，被墙的网站也能返回，直到前几天（估计在11月12日左右），崩了（&amp;gt;_&amp;lt;）。&lt;/p&gt;

&lt;p&gt;面对满页的XX，我换了另一个。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://f.ydr.me/?url=&#34;&gt;http://f.ydr.me/?url=&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是，满页的ie图标是要干啥（不支持的被墙的网站）&lt;/p&gt;

&lt;p&gt;后来，看到了一个问答，大概是通过判断图片的MD5来判断是不是小地球（获取失败时返回），我灵感一动，两天的折磨……&lt;/p&gt;

&lt;p&gt;前段框架用的是刚学的vue.js 2，用过滤器 filters 不就可以了吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
{{data_url  | filter}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要我把前面的链接获取到，然后判断那个图标是不是小地球，再来调用其他的api，不就可以了吗。&lt;/p&gt;

&lt;p&gt;但是 vue 不支持在绑定属性中使用过滤器，（&amp;gt;_&amp;lt;），好，再google，(⊙o⊙)哦，要用计算属性 computed 啊！？&lt;/p&gt;

&lt;p&gt;但是计算属性不能传参，（&amp;gt;_&amp;lt;），好，只能再找了，可以用 methods 。&lt;/p&gt;

&lt;p&gt;之前学习了fetch，用fetch下图标，然后直接返回图片，这儿遇到点问题，主要是图片的处理和到最后也没有解决的跨域问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
fetch(img_url)
.then(function(res){
    return res.blob();
})
.then(function(imageBlob){
    img_src = window.URL.createObjectURL(imageBlob);
    //more
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个简单的fetch获取图片的例子，复刻官网上的，本地图片可以加载。&lt;/p&gt;

&lt;p&gt;但是favicon api是不支持跨域请求，所以一直在做挣扎。&lt;/p&gt;

&lt;p&gt;在这段时间之中，把这个方法放到了mounted，想让图片直接在加载时判断。&lt;/p&gt;

&lt;p&gt;主要是因为好好的看了一下js的闭包，之前有过卡在这儿的经历，还好征服了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
for(var i=0;i&amp;lt;json.length;i++){
    (function(i){
        for(var j=0;j&amp;lt;json[i].list.length;j++){
            (function(j){
                fetch(
                &#39;https://s2.googleusercontent.com/s2/favicons?domain=&#39;
                +json[i].list[j].url,
                    {
                        mode:&amp;quot;cors&amp;quot;,
                        headers:{
                        &#39;Access-Control-Allow-Origin&#39;:&#39;*&#39;
                        }
                    }
                )
                .then(function(res){
                    return res.blob();
                })
                .then(function(imageBlob){
                    json[i].list[j].img
                    =window.URL.createObjectURL(imageBlob);
                })
            })(j);
        }
    })(i);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;痛苦的是解决fetch 的跨域问题&lt;/p&gt;

&lt;p&gt;fetch 的response 中有个mode的属性，可取值4个，包括 cors、no-cors等。&lt;/p&gt;

&lt;p&gt;默认为cors，但在请求图片时，浏览器会提醒跨域问题。
当设置为 no-cors 时， 虽然不会报错，但是你并不能获取resquest 中的data，所以然并软。&lt;/p&gt;

&lt;p&gt;还曾引入过fetch-jsonp.js，但是就像no-cors，获取不到内容。&lt;/p&gt;

&lt;p&gt;设置请求头中的Access-Control-Allow-Origin，会提示服务器不支持。&lt;/p&gt;

&lt;p&gt;就当我要放弃时，我又突发奇想，等网页加载完，判断下载本地的图片。&lt;/p&gt;

&lt;p&gt;不能直接获取图片的MD5，找到了别人写的代码，先变成Base64.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
function getBase64Image(img) {
    var canvas = document.createElement(&amp;quot;canvas&amp;quot;);
    canvas.width = img.width;
    canvas.height = img.height;

    var ctx = canvas.getContext(&amp;quot;2d&amp;quot;);
    ctx.drawImage(img, 0, 0, img.width, img.height);

    var dataURL = canvas.toDataURL(&amp;quot;image/png&amp;quot;);
    return dataURL

    // return dataURL.replace(&amp;quot;data:image/png;base64,&amp;quot;, &amp;quot;&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，用SparkMD5，讲Base64编码，再比较。&lt;/p&gt;

&lt;p&gt;小心翼翼地试了下，好像可以。&lt;/p&gt;

&lt;p&gt;但是，当我写好了代码，请求时，浏览器报错传到函数里面的不是一个HTMLElement。
我想是不是因为图片还没有加载完成，获取不到节点，那就判断一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
if (img.complete) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，&lt;strong&gt;canvas&lt;/strong&gt; 不支持跨域 ！&lt;/p&gt;

&lt;p&gt;所以，我放弃了。&lt;/p&gt;

&lt;p&gt;我又重新看了一下开始的API，好像能用了，那就切换回来好了。&lt;/p&gt;

&lt;p&gt;看到他的代码开源，想要自己整一个,以防万一。&lt;/p&gt;

&lt;p&gt;（&amp;gt;_&amp;lt;）为什么是 拍X片 PHP ？？？&lt;/p&gt;

&lt;p&gt;结束&lt;/p&gt;

&lt;p&gt;后记&lt;/p&gt;

&lt;p&gt;当我兴致勃勃的去用java写一个api时，我卡在了线程同步……&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://f12998765.github.io/about/</link>
      <pubDate>Sat, 19 Nov 2016 19:22:33 +0800</pubDate>
      
      <guid>http://f12998765.github.io/about/</guid>
      <description>&lt;p&gt;11月19日，2016.&lt;/p&gt;

&lt;p&gt;早晨来了一场大雪，或许在深夜便开始了。&lt;/p&gt;

&lt;p&gt;这两天，学着别人的模板主题，自己拙略地仿写了一个，虽然粗糙，但毕竟费了一番心血。&lt;/p&gt;

&lt;p&gt;听首歌。&lt;/p&gt;

&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=330 height=86 src=&#34;http://music.163.com/outchain/player?type=2&amp;id=28757341&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;现在的我，没有什么。&lt;/p&gt;

&lt;p&gt;轨迹也是这个时代的缩影，随着人潮和催促而蹉跎。&lt;/p&gt;

&lt;p&gt;这个网站是个开始。&lt;/p&gt;

&lt;p&gt;link :&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/f12998765&#34;&gt;&lt;img src=&#34;../img/github.png&#34; alt=&#34;github&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://twitter.com/f12998765&#34;&gt;&lt;img src=&#34;../img/twitter.png&#34; alt=&#34;twitter&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tags</title>
      <link>http://f12998765.github.io/tags/</link>
      <pubDate>Sat, 19 Nov 2016 17:25:07 +0800</pubDate>
      
      <guid>http://f12998765.github.io/tags/</guid>
      <description>

&lt;h1 id=&#34;java-tags-java&#34;&gt;&lt;a href=&#34;http://f12998765.github.io/tags/java&#34;&gt;Java&lt;/a&gt;&lt;/h1&gt;

&lt;h1 id=&#34;note-tags-note&#34;&gt;&lt;a href=&#34;http://f12998765.github.io/tags/note&#34;&gt;Note&lt;/a&gt;&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Centos 配置指南</title>
      <link>http://f12998765.github.io/notes/centos-note/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://f12998765.github.io/notes/centos-note/</guid>
      <description>

&lt;h2 id=&#34;ssh-配置修改&#34;&gt;SSH 配置修改&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#修改ssh配置
vim /etc/ssh/sshd_config

#使用第二代通讯协定
Protocol 2

#不容许空白密码
PermitEmptyPasswords no

#禁止root 使用SSH 登入
PermitRootLogin no

#重新启动sshd
systemctl restart sshd.service
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;更新系统和软件&#34;&gt;更新系统和软件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yum update &amp;amp;&amp;amp; yum upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建用户赋予权限&#34;&gt;创建用户赋予权限&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#创建用户，修改密码
useradd [username]
passwd [username]

#修改权限
EDITOR=nano visudo
#修改 %wheel ALL=(ALL) ALL

#修改用户组
usermod -aG wheel [username]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;更改计算机的名称&#34;&gt;更改计算机的名称&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo hostnamectl --static set-hostname &amp;lt;host-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装-mysql&#34;&gt;安装 MySQL&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#添加源
wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm

#安装软件包
rpm -ivh mysql-community-release-el7-5.noarch.rpm

#yum 安装
yum install mysql-server

#启动 mysql
systemctl start mysql

#修改root密码
mysqladmin -u root password &amp;quot;newpassword&amp;quot;

#本地登录
mysql -u root -p

#查看用户
mysql &amp;gt; select host,user from user;

#添加远程用户
mysql &amp;gt; Grant all privileges on *.* to &#39;zero&#39;@&#39;%&#39; identified by &#39;zero&#39; with grant option;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Git 常用命令</title>
      <link>http://f12998765.github.io/notes/git-note/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://f12998765.github.io/notes/git-note/</guid>
      <description>

&lt;h2 id=&#34;设置配置文件&#34;&gt;设置配置文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config [--global] user.name &amp;quot;[name]&amp;quot;
git config [--global] user.email &amp;quot;[email]&amp;quot;
git config --global color.ui true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;生成ssh-key&#34;&gt;生成SSH Key&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 检查是否存在
cd ~/.ssh
# 生成SSH Key，在id_rsa.pub中
ssh-keygen -t rsa -C &amp;quot;your_email@example.com&amp;quot;
# 测试
ssh -T git@github.com
ssh -T git@git.coding.net
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;https-方式记住密码&#34;&gt;HTTPS 方式记住密码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config credential.helper store
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;初始化仓库&#34;&gt;初始化仓库&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 初始化仓库
git init [project-name]
# 克隆远程仓库
git clone [project-URL]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;查看当前状态&#34;&gt;查看当前状态&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git status
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;添加到暂存区&#34;&gt;添加到暂存区&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add [-A/.]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;提交代码&#34;&gt;提交代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git commit -m &amp;quot;edit message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建分支&#34;&gt;创建分支&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有本地分支
git branch

# 新建一个分支，但依然停留在当前分支
git branch [branch-name]
# 新建一个分支，并切换到该分支
git checkout -b [branch]

# 切换到指定分支，并更新工作区
git checkout [branch-name]

# 删除分支
git branch -d [branch-name]

# 合并指定分支到当前分支
git merge [branch]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;远程仓库&#34;&gt;远程仓库&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 增加一个新的远程仓库，并命名
git remote add [name] [url]

# 查看当前的远程仓库
git remote -v
# 需要多个远程仓库时，再添加一个新的远程仓库
git remote set-url --add [name] [url]
# 推送多个远程仓库
git push all --all
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;推送&#34;&gt;推送&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 完整命令
git push origin [localbranch]:[remotebranch]
# 忽略远程分支，代表远程分支与本地分支名相同
git push origin [localbranch]
# 忽略本地分支，代表删除远程分支
git push origin :[remotebranch]
# 忽略分支，默认本地分支与远程分支关联
git push
# 设置分支关联
git push --set-upstream origin [remotebranch]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;拉取&#34;&gt;拉取&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 从远程仓库下载分支
git fetch origin master
# 合并分支到当前分支
git merge origin/master
# 拉取远程仓库分支，与当前分支合并
git pull origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;待补充……&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java Annotation（注解）</title>
      <link>http://f12998765.github.io/java-notes/java-%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/java-%E6%B3%A8%E8%A7%A3/</guid>
      <description>

&lt;p&gt;#Annotation（注解）
Java提供的一种元程序中的元素关联任何信息和任何元数据（metadata）的途径和方法。
Annotion(注解)是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。
它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。从某些方面看，annotation就像修饰符一样被使用，并应用于包、类 型、构造方法、方法、成员变量、参数、本地变量的声明中。这些信息被存储在Annotation的“name=value”结构对中。&lt;/p&gt;

&lt;p&gt;当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。&lt;/p&gt;

&lt;h1 id=&#34;注解和注解类型&#34;&gt;注解和注解类型&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;注解类型是一种特殊的接口类型，注解是注解类型的一个实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;#注解类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据注解使用方法和用途：
    1.JDK内置系统注解
    2.元注解
    3.自定义注解&lt;/li&gt;
&lt;li&gt;根据注解键值对的个数：
    1.标记注解
    2.单值注解
    3.多值注解　　
如果注解类型有单个键值对 , 并且键的名称是 value , 那么可以忽略括号中的键&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#元注解&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;注解&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;@Target&lt;/td&gt;
&lt;td&gt;用于描述注解的使用对象&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;@Retention&lt;/td&gt;
&lt;td&gt;表示注解类型的存活时长&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;@Documented&lt;/td&gt;
&lt;td&gt;表示含有该注解类型的元素(带有注释的)会通过javadoc或类似工具进行文档化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;@Inherited&lt;/td&gt;
&lt;td&gt;表示注解类型能被自动继承&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;位于  java.lang.annotation 下&lt;/p&gt;

&lt;p&gt;##@Targe
&lt;strong&gt;用于描述注解的使用对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;value取值为java.lang.annnotation.RetentionPolicy 枚举的成员之一&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ElementType&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ANNOTATION_TYPE&lt;/td&gt;
&lt;td&gt;注解类型声明&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CONSTRUCTOR&lt;/td&gt;
&lt;td&gt;构造方法声明&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FIELD&lt;/td&gt;
&lt;td&gt;字段声明（包括枚举常量）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LOCAL_VARIABLE&lt;/td&gt;
&lt;td&gt;局部变量声明&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;METHOD&lt;/td&gt;
&lt;td&gt;方法声明&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PACKAGE&lt;/td&gt;
&lt;td&gt;包声明&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PARAMETER&lt;/td&gt;
&lt;td&gt;参数声明&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TYPE&lt;/td&gt;
&lt;td&gt;类、接口（包括注解类型）或枚举声明&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;默认策略 , 可作用于任意对象
##@Retention
&lt;strong&gt;定义了该Annotation被保留的时间长短&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;value取值为java.lang.annnotation.ElementType 枚举的成员之一&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;RetentionPolicy&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SOURCE&lt;/td&gt;
&lt;td&gt;源文件有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLASS&lt;/td&gt;
&lt;td&gt;Class字节码文件有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RUNTIME&lt;/td&gt;
&lt;td&gt;运行时有效 , 可通过反射性地读取注解&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;默认保留策略为RetentionPolicy.CLASS&lt;/p&gt;

&lt;p&gt;##@Documented
&lt;strong&gt;当前注解的元素会被javadoc工具进行文档化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;##@Inherited
&lt;strong&gt;表示该注解类型被自动继承&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;#系统内置标准注解：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内建注解&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;Target&lt;/th&gt;
&lt;th&gt;Retention&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Override&lt;/td&gt;
&lt;td&gt;标记注解&lt;/td&gt;
&lt;td&gt;修饰此方法覆盖了父类的方法&lt;/td&gt;
&lt;td&gt;METHOD&lt;/td&gt;
&lt;td&gt;SOURCE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SuppressWarnings&lt;/td&gt;
&lt;td&gt;标记注解&lt;/td&gt;
&lt;td&gt;修饰已经过时的方法&lt;/td&gt;
&lt;td&gt;除ANNOTATION_TYPE和PACKAGE外的所有&lt;/td&gt;
&lt;td&gt;SOURCE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Deprecated&lt;/td&gt;
&lt;td&gt;单值注解&lt;/td&gt;
&lt;td&gt;压制提醒 , 抑制编译器警告&lt;/td&gt;
&lt;td&gt;除ANNOTATION_TYPE外的所有&lt;/td&gt;
&lt;td&gt;RUNTIME&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;##@Override
&lt;strong&gt;告诉编译器该方法覆盖了超类/父类中的一个方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;##@Deprecated
&lt;strong&gt;应用于方法或类型 , 表示该方法或类型是要废弃的&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通常是因为有更好的方法或类型 , 并且兼容低版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;##@SuppressWarnnings
 &lt;strong&gt;抑制编译器警告&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;suppresswarnings-value-注解的常见参数值的简单说明&#34;&gt;@SuppressWarnings(value={})注解的常见参数值的简单说明：&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;deprecation&lt;/td&gt;
&lt;td&gt;使用了不赞成使用的类或方法时的警告&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;unchecked&lt;/td&gt;
&lt;td&gt;执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fallthrough&lt;/td&gt;
&lt;td&gt;当 switch 程序块 case 直接通往下一种情况而没有 break 时的警告&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;path&lt;/td&gt;
&lt;td&gt;在类路径、源文件路径等中有不存在的路径时的警告&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;serial&lt;/td&gt;
&lt;td&gt;当在可序列化的类上缺少 serialVersionUID 定义时的警告&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;finally&lt;/td&gt;
&lt;td&gt;任何 finally 子句不能正常完成时的警告&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;关于以上所有情况的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;#自定义注解
&lt;strong&gt;一个注解类型是一个java接口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Inherited
@Retention
@Documented
@Target(value=ANNOTATION_TYPE)
public @interface CustomAnnotation ( ) {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#使用反射来查询注解
java.lang.Class&lt;/p&gt;

&lt;p&gt;##如果存在，返回指定注解类型的注解；不存在则返回null&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;A extends java.lang.annotation.Annotation&amp;gt; A  getAnnotation ( Class&amp;lt;A&amp;gt; annotationClass )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##返回该类中所有注解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public java.lang.annotation.Annotation[] getAnnotations ( )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##判断该类是不是一个注解类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean isAnnotation()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##判断指定类型的一个注解是否出现在该类上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean isAnnotationPressent( Class&amp;lt;? extends java.lang.annotation.Annotation&amp;gt; annotationClass)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#参考
- &lt;a href=&#34;http://blog.csdn.net/cwcwj3069/article/details/52252670&#34;&gt;《深入理解Java：注解》 cwcwj3069 - CSDN博客 &lt;/a&gt;
- &lt;a href=&#34;http://www.cnblogs.com/kgrdomore/p/5806321.html&#34;&gt;《注解的基本盘点》 墨迹修 - 博客园博客 &lt;/a&gt;
- &lt;a href=&#34;http://gityuan.com/2016/01/23/java-annotation/&#34;&gt;《Java注解(Annotation)》 Gityuan - 个人博客 &lt;/a&gt;
- &lt;a href=&#34;http://www.cnblogs.com/tianzhijiexian/p/4807813.html&#34;&gt;《Java 注解》 Developer_Kale - 博客园博客  &lt;/a&gt;
- 《Java 和 Android 开发学习指南》 （第2版）， [加] Budi Kurniawan 著 ，李强 译  ，人民邮电出版社 2016-3&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java IO</title>
      <link>http://f12998765.github.io/java-notes/java-io/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/java-io/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;关于 Java IO 还没有一个整体的结构，所以先写一点常用的东西&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;h3 id=&#34;io常执行的操作&#34;&gt;IO常执行的操作：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;文件的创建、删除、移动、复制&lt;/li&gt;
&lt;li&gt;对文件或网络套字节中读取和写入&lt;/li&gt;
&lt;li&gt;把对象序列化到持久储存中，并获取保存的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一点历史&#34;&gt;一点历史：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JDK 1.0 ，Java 以 java.io 包中的 I/O API 的形式提供支持 I/O&lt;/li&gt;
&lt;li&gt;JDK 1.4 ，添加了 java.nio&lt;/li&gt;
&lt;li&gt;JDK 1.7 ，引入 NIO.2 的包来补充&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;注意&#34;&gt;注意：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新的版本中，Path 接口是 java.io.File 类的升级&lt;/li&gt;
&lt;li&gt;JDK 1.7 中添加了 java.lang.AutoCloseable 接口，实现了 try-with-resources&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;文件系统-路径和一些工具类&#34;&gt;文件系统、路径和一些工具类&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html&#34;&gt;Interface Path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html&#34;&gt;Class FileSystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html&#34;&gt;Class Paths&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystems.html&#34;&gt;Class FileSystems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;创建一个路径&#34;&gt;创建一个路径&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Paths 的静态方法 get()&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Modifier and Type&lt;/th&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;static Path&lt;/td&gt;
&lt;td&gt;get(String first, String&amp;hellip; more)&lt;/td&gt;
&lt;td&gt;Converts a path string, or a sequence of strings that when joined form a path string, to a Path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;static Path&lt;/td&gt;
&lt;td&gt;get(URI uri)&lt;/td&gt;
&lt;td&gt;Converts the given URI to a Path object.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Path p = Paths.get(&amp;quot;C:/temp&amp;quot;);
Path p_ = Paths.get(&amp;quot;/home&amp;quot;,&amp;quot;user&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;FileSystem 的成员方法 getPath()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;可以通过 FileSystems 的静态方法 getDefault()获取默认的FileSystem&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Modifier and Type&lt;/th&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abstract Path&lt;/td&gt;
&lt;td&gt;getPath(String first, String&amp;hellip; more)&lt;/td&gt;
&lt;td&gt;Converts a path string, or a sequence of strings that when joined form a path string, to a Path.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Path p =FileSystes.getDefault().getPath(&amp;quot;/home&amp;quot;,&amp;quot;user&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;interface-path&#34;&gt;Interface Path&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html&#34;&gt;JDK API : Interface Path&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Modifier and Type&lt;/th&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;normalize()&lt;/td&gt;
&lt;td&gt;路径普通化 Returns a path that is this path with redundant name elements eliminated.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;subpath(int beginIndex, int endIndex)&lt;/td&gt;
&lt;td&gt;截取子路径 Returns a relative Path that is a subsequence of the name elements of this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;判断路径开头和结尾&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;startsWith(Path other)&lt;/td&gt;
&lt;td&gt;Tests if this path starts with the given path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;startsWith(String other)&lt;/td&gt;
&lt;td&gt;Tests if this path starts with a Path, constructed by converting the given path string, in exactly the manner specified by the startsWith(Path) method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;endsWith(Path other)&lt;/td&gt;
&lt;td&gt;Tests if this path ends with the given path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;endsWith(String other)&lt;/td&gt;
&lt;td&gt;Tests if this path ends with a Path, constructed by converting the given path string, in exactly the manner specified by the endsWith(Path) method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;获取路径的相关信息&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;getFileName()&lt;/td&gt;
&lt;td&gt;Returns the name of the file or directory denoted by this path as a Path object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FileSystem&lt;/td&gt;
&lt;td&gt;getFileSystem()&lt;/td&gt;
&lt;td&gt;Returns the file system that created this object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;getName(int index)&lt;/td&gt;
&lt;td&gt;Returns a name element of this path as a Path object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;getNameCount()&lt;/td&gt;
&lt;td&gt;Returns the number of name elements in the path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;getParent()&lt;/td&gt;
&lt;td&gt;Returns the parent path, or null if this path does not have a parent.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;getRoot()&lt;/td&gt;
&lt;td&gt;Returns the root component of this path as a Path object, or null if this path does not have a root component.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Path to Path&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;relativize(Path other)&lt;/td&gt;
&lt;td&gt;Constructs a relative path between this path and a given path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;路径替换拼接&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;resolve(Path other)&lt;/td&gt;
&lt;td&gt;Resolve the given path against this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;resolve(String other)&lt;/td&gt;
&lt;td&gt;Converts a given path string to a Path and resolves it against this Path in exactly the manner specified by the resolve method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;resolveSibling(Path other)&lt;/td&gt;
&lt;td&gt;Resolves the given path against this path&amp;rsquo;s parent path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;resolveSibling(String other)&lt;/td&gt;
&lt;td&gt;Converts a given path string to a Path and resolves it against this path&amp;rsquo;s parent path in exactly the manner specified by the resolveSibling method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;转换&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;isAbsolute()&lt;/td&gt;
&lt;td&gt;Tells whether or not this path is absolute.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;toAbsolutePath()&lt;/td&gt;
&lt;td&gt;Returns a Path object representing the absolute path of this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;File&lt;/td&gt;
&lt;td&gt;toFile()&lt;/td&gt;
&lt;td&gt;Returns a File object representing this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;toRealPath(LinkOption&amp;hellip; options)&lt;/td&gt;
&lt;td&gt;Returns the real path of an existing file.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;URI&lt;/td&gt;
&lt;td&gt;toUri()&lt;/td&gt;
&lt;td&gt;Returns a URI to represent this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;toString()&lt;/td&gt;
&lt;td&gt;Returns the string representation of this path.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;deleteIfExists(Path)  删除不存在path时，不会报 NoSuchFileException  异常 。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>