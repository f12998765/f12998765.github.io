<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.17" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="//fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="/css/main.css">
<link rel="alternate" href="/index.xml" type="application/rss+xml" title="XIZERO">
<link href="https://cdn.bootcss.com/highlight.js/9.7.0/styles/tomorrow.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<title>Java 反射 - XIZERO</title>
</head>
<body>


	
		<div class="header">
			<a href="/">XIZERO</a>
			<div class="gos">
				<span class="go"><a href="/">Home</a></span>
				<span class="go"><a href="/tags">Tags</a></span>
				<span class="go"><a href="/about">About</a></span>
			</div>
		</div>
	


	<main role="main">
		<article itemscope itemtype="http://schema.org/BlogPosting">
			<div class="md_title" itemprop="headline">Java 反射</div>
			<div class="md_tag">
				
					<span> <a href="/tags/java">/java</a></span>
				
					<span> <a href="/tags/%E6%80%BB%E7%BB%93">/总结</a></span>
				
					<span> <a href="/tags/%E5%8F%8D%E5%B0%84">/反射</a></span>
				
			</div>
			<div class="md_meta"><time itemprop="datePublished" datetime="2016-11-18">11月18日 2016</time></div>
			<hr class="md_hr">
			<section itemprop="entry-text" class="md_content">
				

<p><strong>反射是将java 类中的各种成分映射成相应的类。</strong></p>

<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>

<h2 id="class-name">Class Name</h2>

<h3 id="获取完整类名">获取完整类名</h3>

<pre><code class="language-java">String className = class.getName();
</code></pre>

<h3 id="获取不包含包名的类名">获取不包含包名的类名</h3>

<pre><code class="language-java">String simpleClassName = class.getWSimpleName();
</code></pre>

<h2 id="class-modifies">Class Modifies</h2>

<h3 id="获取修饰class-对象的访问修饰符">获取修饰Class 对象的访问修饰符</h3>

<pre><code class="language-java">int modifiers = class.getModifiers();
</code></pre>

<h3 id="检查修饰符">检查修饰符</h3>

<pre><code class="language-java">import  java.lang.reflect.Modifier;

Modifier.isAbstract(int modifiers)
Modifier.isFinal(int modifiers)
Modifier.isInterface(int modifiers)
Modifier.isNative(int modifiers)
Modifier.isPrivate(int modifiers)
Modifier.isProtected(int modifiers)
Modifier.isPublic(int modifiers)
Modifier.isStatic(int modifiers)
Modifier.isStrict(int modifiers)
Modifier.isSynchronized(int modifiers)
Modifier.isTransient(int modifiers)
Modifier.isVolatile(int modifiers)
</code></pre>

<h2 id="package-info">Package Info</h2>

<p>获取包的相关信息：</p>

<pre><code>Package package = class.getPackage();
</code></pre>

<h2 id="superclass">Superclass</h2>

<p>获取超类</p>

<pre><code class="language-java">Class superclass = class.getSuperclass();
</code></pre>

<h2 id="implemented-interfaces">Implemented Interfaces</h2>

<p>获得类实现的接口的列表</p>

<pre><code class="language-java">Class[] interfaces = class.getInterfaces();
</code></pre>

<p>要获取一个给定类的完整的所实现接口的列表，需要递归查询该类以及它的超类。</p>

<h2 id="constructors">Constructors</h2>

<h3 id="获得构造函数">获得构造函数</h3>

<pre><code class="language-java">Constructor[] constructors = class.getConstructors();
</code></pre>

<h3 id="获取指定参数的构造函数">获取指定参数的构造函数</h3>

<pre><code class="language-java">Constructor constructor = class.getConstructor(new Class[]{String.class});
</code></pre>

<h3 id="获取构造函数的参数">获取构造函数的参数</h3>

<pre><code class="language-java">Class[] parameterTypes = constructor.getParameterTypes();
</code></pre>

<h3 id="调用构造函数-实例化对象">调用构造函数，实例化对象</h3>

<pre><code class="language-java">Constructor constructor = MyObject.class.getConstructor(String.class);
MyObject myObject = (MyObject) constructor.newInstance(&quot;参数&quot;);
</code></pre>

<h2 id="methods">Methods</h2>

<h3 id="获取类中的公共方法">获取类中的公共方法</h3>

<pre><code class="language-java">Method[] method = class.getMethods();
</code></pre>

<h3 id="获取指定的方法">获取指定的方法</h3>

<pre><code class="language-java">//不存在与参数匹配的方法时，报 NoSuchMethodException 异常
Method method = class.getMethod(&quot;doSomething&quot;, new Class[]{String.class});
Method method = aClass.getMethod(&quot;doSomething&quot;, null);
</code></pre>

<h3 id="获取方法的参数">获取方法的参数</h3>

<pre><code class="language-java">Class[] parameterTypes = method.getParameterTypes();
</code></pre>

<h3 id="获取方法的返回值类型">获取方法的返回值类型</h3>

<pre><code class="language-java">Class returnType = method.getReturnType();
</code></pre>

<h3 id="调用方法">调用方法</h3>

<pre><code class="language-java">Method.invoke(Object target, Object... parameters)
//参数  target  是要调用方法的对象
//静态方法需要提供null作为参数，非静态方法需要提供对象的实例。

Method method = MyObject.class.getMethod(&quot;doSomething&quot;, String.class);
Object returnValue = method.invoke(null, &quot;parameter-value1&quot;);
</code></pre>

<h2 id="fields">Fields</h2>

<h3 id="获取类的公共字段">获取类的公共字段</h3>

<pre><code class="language-java">Field[] fields = class.getFields();
</code></pre>

<h3 id="获取指定字段名的字段">获取指定字段名的字段</h3>

<pre><code class="language-java">Field field = class.getField(&quot;字段名&quot;);
</code></pre>

<h3 id="根据字段获取字段名">根据字段获取字段名</h3>

<pre><code class="language-java">String fieldName = field.getName();
</code></pre>

<h3 id="根据字段获取字段类型">根据字段获取字段类型</h3>

<pre><code class="language-java">Class fieldType = field.getType();
</code></pre>

<h3 id="通过字段获取设置字段的值">通过字段获取设置字段的值</h3>

<pre><code class="language-java">//参数objectInstance必须是拥有该字段的实例
Class  class_  = MyObject.class
Field field = class_.getField(&quot;字段名&quot;);
MyObject objectInstance = new MyObject();
Object value = field.get(objectInstance);
field.set(objetInstance, value);
</code></pre>

<h2 id="annotations">Annotations</h2>

<pre><code class="language-java">Annotation[] annotations = class.getAnnotations();
</code></pre>

<h2 id="关于私有成员">关于私有成员</h2>

<h3 id="私有字段">私有字段</h3>

<p>获得私有字段，仅仅在当前类中</p>

<pre><code class="language-java">Field field = class.getDeclaredField(String name);

Field[] fields = class.getDeclaredFields();

field.setAccessible(true); //关闭对特定的Field实例的访问检查
</code></pre>

<h3 id="私有方法">私有方法</h3>

<p>获得私有方法，仅仅在当前类中</p>

<pre><code class="language-java">Method  method = class.getDeclaredMethod(String name, Class[ ] parameterTypes);

Method[] method = class.getDeclaredMethods();

method.setAccessible(true); //关闭对特定的Method实例的访问检查
</code></pre>

<h2 id="数组">数组</h2>

<h3 id="创建数组">创建数组</h3>

<pre><code class="language-java">import java.lang.reflect.Array;

int[] intArray = (int[]) Array.newInstance(int.class, 3);
//第一个参数int.class指定了数组类型。
//第二个参数声明了数组大小。
</code></pre>

<h3 id="get-和-set">get 和 set</h3>

<pre><code class="language-java">Array.get(数组实例,序列);

Array.set(数组实例,序列,值);
</code></pre>

<h3 id="获取数组的类型">获取数组的类型</h3>

<pre><code class="language-java">Class class_ = class.getComponentType();
</code></pre>

<p>#参考
- <a href="http://www.cnblogs.com/penghongwei/p/3299688.html">Java 反射 【译】</a>
- <a href="http://tutorials.jenkov.com/java-reflection/index.html">java-reflection [英] </a></p>

			</section>
		</article>
	</main>

<hr class="md_hr">
<div class="footer">
	@XIZERO Powered by <a href="http://hugo.spf13.com/">Hugo</a> and <a href="#">bigbig</a>
</div>
</body>
</html>

