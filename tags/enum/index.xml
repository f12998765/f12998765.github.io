<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XIZERO</title>
    <link>http://f12998765.github.io/tags/enum/index.xml</link>
    <description>Recent content on XIZERO</description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="http://f12998765.github.io/tags/enum/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java enum</title>
      <link>http://f12998765.github.io/java-notes/java-%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/java-%E6%9E%9A%E4%B8%BE/</guid>
      <description>

&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum enumName{
    parm1,
    parm2,
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类（抽象类）的子类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;枚举类型符合通用模式 Class Enum&lt;E extends Enum&lt;E&gt;&amp;gt;，而 E 表示枚举类型的名称。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;switch&#34;&gt;switch&lt;/h2&gt;

&lt;p&gt;例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App
{
     private enum INT{
        one,two,three
    }
    public static void main(String[] args) {
        INT c = INT.one;

       // 注意case中必须写成one
        switch (c){
            case one:{
                System.out.println(&amp;quot;1&amp;quot;);
                break;
            }
            case two:{
                System.out.println(&amp;quot;2&amp;quot;);
                break;
            }
            case three:{
                System.out.println(&amp;quot;3&amp;quot;);
                break;
            }
            default:{
                System.out.println(&amp;quot;0&amp;quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;成员变量与构造函数&#34;&gt;成员变量与构造函数&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果定义的枚举有自己的构造函数必须声明私有的&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App
{
     private enum INT{
        one(1,&amp;quot;one&amp;quot;),two(2,&amp;quot;two&amp;quot;),three(2,&amp;quot;three&amp;quot;);//注意有分号  

         int i;
         String name;

        INT(int i, String name) {
             this.i = i;
             this.name = name;
         }
         public int getI() {
             return i;
         }
         public void setI(int i) {
             this.i = i;
         }
         public String getName() {
             return name;
         }
         public void setName(String name) {
             this.name = name;
         }
     }
    public static void main(String[] args) {

        INT[] ints = INT.values();
        for(INT n :ints){
            System.out.println(&amp;quot;name : \t&amp;quot;+n.getName());
            System.out.println(&amp;quot;index : \t&amp;quot;+n.getI());
            System.out.println(&amp;quot;oridary : \t&amp;quot;+n.ordinal());
            System.out.println(&amp;quot;this : \t&amp;quot;+n);
            System.out.println(&amp;quot;name : \t&amp;quot;+n.name());
            System.out.println(&amp;quot;name : \t&amp;quot;+n.valueOf(&amp;quot;two&amp;quot;));
            System.out.println(&amp;quot;---------------------&amp;quot;);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ordinal()&lt;/td&gt;
&lt;td&gt;返回枚举值在枚举类种的顺序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;values()&lt;/td&gt;
&lt;td&gt;静态方法，返回一个包含全部枚举值的数组&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;toString()&lt;/td&gt;
&lt;td&gt;返回枚举常量的名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;valueOf()&lt;/td&gt;
&lt;td&gt;返回带指定名称的指定枚举类型的枚举常量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;实现接口&#34;&gt;实现接口&lt;/h2&gt;

&lt;p&gt;可以更方便地对枚举中的值进行排序、比较等操作，封装性更好.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   interface INT_ {
        void read();

        String getState();
    }

     private enum INT implements INT_{
        one(1,&amp;quot;one&amp;quot;),two(2,&amp;quot;two&amp;quot;),three(2,&amp;quot;three&amp;quot;);

         int i;
         String name;

        INT(int i, String name) {
             this.i = i;
             this.name = name;
         }

         @Override
         public void read() {

         }

         @Override
         public String getState() {
             return null;
         }
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;enummap-和-enumset&#34;&gt;EnumMap 和 EnumSet&lt;/h2&gt;

&lt;h3 id=&#34;enummap&#34;&gt;EnumMap&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void main(String[] args) {

        EnumMap&amp;lt;INT,String&amp;gt; ints = new EnumMap&amp;lt;INT,String&amp;gt;(INT.class);
        ints.put(INT.one,&amp;quot;11111111&amp;quot;);
        ints.put(INT.two,&amp;quot;22222222&amp;quot;);
        ints.put(INT.three,&amp;quot;333333333&amp;quot;);
        Set&amp;lt;INT&amp;gt; keys = ints.keySet();
        for(INT i:keys)
        {
            System.out.println(i.name()+&amp;quot; &amp;quot;+i.ordinal()+&amp;quot; &amp;quot;+ints.get(i));
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enumset&#34;&gt;EnumSet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void main(String[] args) {

        EnumSet&amp;lt;INT&amp;gt; ints = EnumSet.allOf(INT.class);
        for(INT i : ints)
        {
            System.out.println(i);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>