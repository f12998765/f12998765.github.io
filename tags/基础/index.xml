<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础 on XIZERO</title>
    <link>https://www.xizero.com/tags/%E5%9F%BA%E7%A1%80/index.xml</link>
    <description>Recent content in 基础 on XIZERO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://www.xizero.com/tags/%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>String 相关</title>
      <link>https://www.xizero.com/java/String%20%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Tue, 22 Nov 2016 08:36:39 +0800</pubDate>
      
      <guid>https://www.xizero.com/java/String%20%E7%9B%B8%E5%85%B3/</guid>
      <description>

&lt;h2 id=&#34;string-成员变量&#34;&gt;String 成员变量&lt;/h2&gt;

&lt;p&gt;String 是典型的&lt;a href=&#34;http://www.cnblogs.com/java-my-life/archive/2012/05/08/2487757.html&#34;&gt;不变模式设计&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/String.java?av=f&#34;&gt;JDK 8 源码地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/String.java?av=f&#34;&gt;JDK 6 源码地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
//JDK 1.8
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {
	//The value is used for character storage.
	private final char value[];

	//Cache the hash code for the string
	private int hash; // Default to 0
}

//JDK1.6
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence{
	//The value is used for character storage.
	private final char value[];

	//The offset is the first index of the storage that is used.
	private final int offset;

	//The count is the number of characters in the String.
	private final int count;

	//Cache the hash code for the string
	private int hash; // Default to 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常量池&#34;&gt;常量池&lt;/h2&gt;

&lt;p&gt;java编译时会生成常量池（Constant pool），保存字面常量和符号引用（类名、方法名、接口名和字段名等）。&lt;/p&gt;

&lt;h3 id=&#34;创建字符串对象&#34;&gt;创建字符串对象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;new 运算符&lt;/li&gt;
&lt;li&gt;字符串常量&lt;/li&gt;
&lt;li&gt;&amp;rdquo;+&amp;ldquo;连接的表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相同的字符串常量或结果相同的字符串常量表达式创建字符串对象时，
如果常量池中已经存在，相同序列的字符串，则该对象直接指向；不存在时，会在常量池创建一个新的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String a1 = &amp;quot;abc&amp;quot;;
String a2 = &amp;quot;abc&amp;quot;;
String a3 = &amp;quot;a&amp;quot;+&amp;quot;bc&amp;quot;;
System,out.println(a1==a2+&amp;quot;\t&amp;quot;+a2==a3); //true true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为字符串序列相同，指向的常量池中同一个字符串，所以为true。&lt;/p&gt;

&lt;p&gt;使用 new 创建字符串对象时，会在堆中创建一个新的String对象，并且该String对象的char value[]会指向常量池中的字符串，不存在则创建。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
String b1 = new String(&amp;quot;abc&amp;quot;);
String b2 = new String(&amp;quot;abc&amp;quot;);
System.out.println(b1==b2); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用new会在堆中创建新的对象,地址当然不同.&lt;/p&gt;

&lt;h3 id=&#34;string&#34;&gt;String +&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&amp;rdquo; &amp;ldquo;+[String] 或 [String]+[String]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;会在编译时,调用StringBuilder的append()和toString(),最终指向的是堆上新创建的String对象.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String c1 = &amp;quot;abc&amp;quot;;
String c2 = &amp;quot;123&amp;quot;+c1;
String c3 = &amp;quot;123abc&amp;quot;;
System.out.println(c2==c3); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;rdquo; &amp;ldquo;+&amp;rdquo; &amp;ldquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[final String]+[final String] 或 [final String]+&amp;rdquo; &amp;ldquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当final修饰的对象发生连接动作时，虚拟机会进行优化，将表达式结果直接赋值给目标变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final String a = &amp;quot;hello &amp;quot;;
final String b = &amp;quot;world&amp;quot;;
String c = a + &amp;quot;world&amp;quot;;
String d = &amp;quot;hello world&amp;quot;;
System.out.println(c==d); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string-intern&#34;&gt;String.intern()&lt;/h2&gt;

&lt;p&gt;是一个 Native 方法，调用 C++的 StringTable::intern&lt;/p&gt;

&lt;p&gt;如果常量池中已经存在该字符串，则返回池中的字符串；否则将此字符串添加到常量池中，并返回引用。&lt;/p&gt;

&lt;h2 id=&#34;string-substring&#34;&gt;String.substring()&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//JDK1.6
public String substring(int beginIndex) {
	return substring(beginIndex, count);
}
public String substring(int beginIndex, int endIndex) {
	if (beginIndex &amp;lt; 0) {
		throw new StringIndexOutOfBoundsException(beginIndex);
	}
	if (endIndex &amp;gt; count) {
		throw new StringIndexOutOfBoundsException(endIndex);
	}
	if (beginIndex &amp;gt; endIndex) {
		throw new StringIndexOutOfBoundsException(endIndex - beginIndex);
	}
	return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == count)) ? this :
		new String(offset + beginIndex, endIndex - beginIndex, value);
}

String(int offset, int count, char value[]) {
	this.value = value;
	this.offset = offset;
	this.count = count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JDK1.6 中的实现只是调整了 offset 和 count ,使用的是共享的字符数组。&lt;/p&gt;

&lt;p&gt;当使用substring截取一个很长的字符串的2个字符时，会占用这个长字符串，不能垃圾回收。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//JDK 1.8
public String substring(int beginIndex) {
        if (beginIndex &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        int subLen = value.length - beginIndex;
		if (subLen &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}

public String substring(int beginIndex, int endIndex) {
		if (beginIndex &amp;lt; 0) {
			throw new StringIndexOutOfBoundsException(beginIndex);
		}
		if (endIndex &amp;gt; value.length) {
			throw new StringIndexOutOfBoundsException(endIndex);
		}
		int subLen = endIndex - beginIndex;
		if (subLen &amp;lt; 0) {
			throw new StringIndexOutOfBoundsException(subLen);
		}
		return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);
}

public String(char value[], int offset, int count) {
		if (offset &amp;lt; 0) {
			throw new StringIndexOutOfBoundsException(offset);
		}
		if (count &amp;lt; 0) {
			throw new StringIndexOutOfBoundsException(count);
		}
		// Note: offset or count might be near -1&amp;gt;&amp;gt;&amp;gt;1.
		if (offset &amp;gt; value.length - count) {
			throw new StringIndexOutOfBoundsException(offset + count);
		}
		this.value = Arrays.copyOfRange(value, offset, offset+count);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析一下 substring 源码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;报StringIndexOutOfBoundsException异常

&lt;ul&gt;
&lt;li&gt;beginIndex &amp;lt; 0&lt;/li&gt;
&lt;li&gt;endIndex &amp;gt; value.length&lt;/li&gt;
&lt;li&gt;subLen &amp;lt; 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;subLen 是新的字符串的长度&lt;/li&gt;
&lt;li&gt;endIndex的意义不明确

&lt;ul&gt;
&lt;li&gt;理解为 beginIndex + subLen&lt;/li&gt;
&lt;li&gt;beginIndex &amp;lt;= endIndex &amp;lt;= value.length&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当截取范围与原字符串相同返回this，否则 new 一个新的String对象,在构造方法中复制生成了新的 value。&lt;/li&gt;
&lt;li&gt;substring(1,1)

&lt;ul&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;==s.substring(1,1) //true&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;.equals(s.substring(1,1)) //false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过反射机制可以对String进行修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;== 和 equals()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;== 比较引用是否指向堆内存中的同一个String对象&lt;/li&gt;
&lt;li&gt;equals() 比较的是字符串的内容是否相同&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String StringBuilder StringBuffer 区别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;String是不可变(final)类，每次在String对象上的操作都会生成一个新的对象；&lt;/li&gt;
&lt;li&gt;StringBuffer和StringBuilder是可变的，它允许在原来对象上进行操作，而不用每次增加对象；&lt;/li&gt;
&lt;li&gt;StringBuffer是线程安全的，但效率较低，而StringBuilder则不是线程安全的，效率最高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/21711.html&#34;&gt;浅谈Java String内幕（上）&lt;/a&gt; &amp;ndash; javap 查看字节码&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/99&#34;&gt;Java 7 源码学习系列（一）——String&lt;/a&gt; &amp;ndash; 看源码解释&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://brokendreams.iteye.com/blog/2260870&#34;&gt;关于Java String的一些总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java 语法基础</title>
      <link>https://www.xizero.com/java/java-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>https://www.xizero.com/java/java-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</guid>
      <description>

&lt;h2 id=&#34;1-什么是变量&#34;&gt;1 什么是变量？&lt;/h2&gt;

&lt;p&gt;变量是内存中存放并不确定数据的一个存储空间，可以重复使用。&lt;/p&gt;

&lt;p&gt;一个变量包含：&lt;strong&gt;数据类型&lt;/strong&gt;、&lt;strong&gt;标识符&lt;/strong&gt;、&lt;strong&gt;初始值&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-数据类型&#34;&gt;2 数据类型&lt;/h2&gt;

&lt;h3 id=&#34;基本的数据类型-四类八种&#34;&gt;基本的数据类型 &lt;code&gt;&amp;lt;四类八种&amp;gt;&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;整数：byte、short、&lt;strong&gt;int&lt;/strong&gt;、long&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;浮点数：float、&lt;strong&gt;double&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符：char&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;布尔：boolean&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;引用数据类型&#34;&gt;引用数据类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;数据类型的转换&#34;&gt;数据类型的转换&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;级别从低到高为：&lt;/strong&gt;byte,char,short &amp;ndash;&amp;gt; int &amp;ndash;&amp;gt; float &amp;ndash;&amp;gt; long &amp;ndash;&amp;gt; double&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自动类型转换：&lt;/strong&gt;从低级别到高级别，系统自动转的；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;强制类型转换：&lt;/strong&gt;将一个高级别的值赋给低级别的变量，如 &lt;code&gt;int x=(int)(1.34)&lt;/code&gt;；&lt;/p&gt;

&lt;h2 id=&#34;3-标识符&#34;&gt;3 标识符&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;标示符（ID_entifier_）是指用来标识某个实体的一个符号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;标识符定义规则：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组成：&lt;strong&gt;数字、英文字母、&lt;code&gt;$&lt;/code&gt;、&lt;code&gt;_&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字不可以开头&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不可使用关键字&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-命名规则&#34;&gt;4 命名规则&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;所有的命名都要求符合&lt;strong&gt;标识符&lt;/strong&gt;的规则，并且具有可读性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;变量、方法&lt;/strong&gt;：首字母小写。当包含多个单词时，除第一个单词首字母小写，其他单词的首字母都大写。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;：首字母必须大写。当包含多个单词，每个单词的首字母都要大写。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;程序文件名&lt;/strong&gt;：程序的文件名必须和公共类的名称匹配。最多有一个公共类。不含公共类时可随意命名。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-java-常量&#34;&gt;5 Java 常量&lt;/h2&gt;

&lt;p&gt;使用修饰符&lt;code&gt;final&lt;/code&gt;声明，一旦赋值不可修改，常量名通常大写，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
final int Pai = 3.14 ;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-java-运算符&#34;&gt;6 Java 运算符&lt;/h2&gt;

&lt;h3 id=&#34;运算符分类&#34;&gt;运算符分类&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算术运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 连接符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;++&lt;/code&gt; &lt;code&gt;--&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关系运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逻辑运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;!&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;位运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;^&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 右移补零&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;赋值运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;=&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;+=&lt;/code&gt; &lt;code&gt;-=&lt;/code&gt; &lt;code&gt;*=&lt;/code&gt; &lt;code&gt;/=&lt;/code&gt; &lt;code&gt;%=&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;amp;=&lt;/code&gt; &lt;code&gt;|=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;条件运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;变量&lt;code&gt;=&lt;/code&gt;条件&lt;code&gt;：&lt;/code&gt;x值&lt;code&gt;?&lt;/code&gt;y值&lt;code&gt;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;instanceOf 运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;boolean result = object instanceof class;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;判断变量引用的是否是当前类或它的子类的实例 ，返回布尔值。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;关系运算符和逻辑运算符的结果都是布尔值&lt;/p&gt;

&lt;p&gt;位运算符适用类型：整数（byte、short、int、long）与字符型（char）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;关于-和-和&#34;&gt;关于&amp;amp;和&amp;amp;&amp;amp;、|和||&lt;/h3&gt;

&lt;p&gt;&amp;amp;&amp;amp;和||是逻辑运算符，操作数都是布尔值，结果也是布尔值。&lt;/p&gt;

&lt;p&gt;&amp;amp;和|是位运算符，计算时会将操作数转化为二进制，结果也为数。&lt;/p&gt;

&lt;p&gt;&amp;amp;&amp;amp;和||当知道左侧值时，可能不会执行右侧表达式，因此被称为&lt;strong&gt;短路与和短路或&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&amp;amp;和|，因为要对两侧的值进行与或位运算，所以不会遗忘右侧值。&lt;/p&gt;

&lt;p&gt;之所以会有这样的称呼与用法，可能与布尔类型的&lt;strong&gt;存储类型&lt;/strong&gt;有关。&lt;/p&gt;

&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;

&lt;p&gt;自行查阅。&lt;/p&gt;

&lt;h2 id=&#34;7-流程控制&#34;&gt;7 流程控制&lt;/h2&gt;

&lt;h3 id=&#34;条件判断&#34;&gt;条件判断&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;if 语句&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
if(Boolean_expression){

 //Executes when the Boolean expression is true

}else{

 //Executes when the Boolean expression is false

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;switch 语句&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
switch(expression){

 case value :

 //Statements

 break; //optional

 case value :

 //Statements

 break; //optional

 //You can have any number of case statements.

 default : //Optional

 //Statements

}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;expression可取类型：byte、short、int、枚举、char、**String **&amp;lt;JDK 7支持String，long不支持&amp;gt;。&lt;/p&gt;

&lt;p&gt;case的value必须是常量，可以用final修饰定义。&lt;/p&gt;

&lt;p&gt;default可以写在switch结构中的任意位置，&lt;strong&gt;如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;循环控制&#34;&gt;循环控制&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;while 循环&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
while(Boolean_expression)

{

 //Statements

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;do&amp;hellip;while 循环&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
do

{

 //Statements

} while (Boolean_expression);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;for 循环&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
for(initialization; Boolean_expression; update)

{

 //Statements

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;for-feach循环&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
for( type element : Collection )

{

 //Statements

}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;适用于 Collection 实现及数组。&lt;/p&gt;

&lt;p&gt;更多 &lt;strong&gt;for-feach循环&lt;/strong&gt; 内容，请看java 迭代器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;中断关键字&#34;&gt;中断关键字&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;break&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作用于switch语句和循环语句，用于跳出\/结束语句。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;双重循环中，在外循环前加标号，如 &amp;ldquo;&lt;code&gt;label：&lt;/code&gt;&amp;rdquo; ，内层循环中可以用 &amp;ldquo;&lt;code&gt;break label;&lt;/code&gt;&amp;rdquo; 跳出双重循环&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;continue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作用于循环语句，用于结束本次循环。&lt;/p&gt;

&lt;p&gt;** return**&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;返回指定类型的值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结束方法的执行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>