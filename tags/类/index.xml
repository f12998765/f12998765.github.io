<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XIZERO</title>
    <link>http://f12998765.github.io/tags/%E7%B1%BB/index.xml</link>
    <description>Recent content on XIZERO</description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="http://f12998765.github.io/tags/%E7%B1%BB/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java 核心类</title>
      <link>http://f12998765.github.io/java-notes/java-%E6%A0%B8%E5%BF%83%E7%B1%BB/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/java-%E6%A0%B8%E5%BF%83%E7%B1%BB/</guid>
      <description>

&lt;h1 id=&#34;java-lang-object&#34;&gt;java.lang.Object&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;equals&lt;/td&gt;
&lt;td&gt;将该对象与传入的对象比较&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;toString&lt;/td&gt;
&lt;td&gt;返回该对象的说明&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;hashCode&lt;/td&gt;
&lt;td&gt;返回该对象的一个哈希值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;getClass&lt;/td&gt;
&lt;td&gt;返回该对象的一个java.lang.Class对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;java-lang-string&#34;&gt;java.lang.String&lt;/h1&gt;

&lt;p&gt;String 对象表示一个字符串。一个String对象是常量。&lt;/p&gt;

&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//常见，直接将字符串赋值给对象
String s = &amp;quot;java is cool&amp;quot;;

//使用new来构建一个String对象
String m = new String(&amp;quot;Hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;字符串赋值和new关键字赋值的不同。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s1=&amp;quot;Java&amp;quot;;
String s2=&amp;quot;Java&amp;quot;;
if(s1==s2){ }//ture
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s1 = new String(&amp;quot;Java&amp;quot;);
String s2 = new String(&amp;quot;Java&amp;quot;);
if(s1 == s2){ }//false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;equals方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if(s1 != null &amp;amp;&amp;amp; s1.equals(&amp;quot;java&amp;quot;))   //s1为空时，会有运行时异常
if(&amp;quot;Java&amp;quot;.equals(s1)   //常用
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字符串赋值&#34;&gt;字符串赋值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;字符串以&lt;code&gt;&amp;quot;&lt;/code&gt;开始和结束，不可以在结束双引号之前换行。&lt;/li&gt;
&lt;li&gt;可以使用加号连接符&lt;code&gt;+&lt;/code&gt;将多个字符串连接起来。&lt;/li&gt;
&lt;li&gt;将 String 与基本类型或其他类型连接，或调用后者的&lt;code&gt;toString()&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;switch&#34;&gt;switch&lt;/h2&gt;

&lt;p&gt;从 Java 7开始，可以对一个 String 使用switch 语句。&lt;/p&gt;

&lt;h2 id=&#34;string-类的方法&#34;&gt;String 类的方法&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;public char charAt(int index)&lt;/td&gt;
&lt;td&gt;返回指定索引的字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String concat(String s)&lt;/td&gt;
&lt;td&gt;在末尾连接字符串，并返回结果&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public boolean equals(String s)&lt;/td&gt;
&lt;td&gt;比较字符串的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public boolean startWith(String prefix)&lt;/td&gt;
&lt;td&gt;测试是否以指定的前缀开头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public boolean endsWith(String suffix)&lt;/td&gt;
&lt;td&gt;测试是否以指定的后缀结尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public int indexOf(String substring)&lt;/td&gt;
&lt;td&gt;返回指定子字符串第一次出现的索引位置，不存在，返回 -1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public int indexOf(String substring ,int formIndex)&lt;/td&gt;
&lt;td&gt;返回指定子字符串从指定索引开始的出现的第一次索引位置，不存在，返回 -1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public int lastIndexOf(String substring)&lt;/td&gt;
&lt;td&gt;返回指定字符串最后一次出现的索引位置,不存在，返回 -1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public int lastindexOf(String substring,int formIndex)&lt;/td&gt;
&lt;td&gt;返回指定子字符串从指定索引开始的出现的最后一次索引位置，不存在，返回 -1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String substring(int beginIndex)&lt;/td&gt;
&lt;td&gt;返回从指定索引开始的，到末尾的子字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String substring(int beginIndex,int endIndex)&lt;/td&gt;
&lt;td&gt;返回从beginIndex开始到endIndex结束的子字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String replace(char oldChar,char newChar)&lt;/td&gt;
&lt;td&gt;将oldChar 替换为newOld，并返回新的字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public int length()&lt;/td&gt;
&lt;td&gt;返回字符串的长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public boolean isEmpty()&lt;/td&gt;
&lt;td&gt;判断字符串是否为空&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String[] split(String regEx)&lt;/td&gt;
&lt;td&gt;使用指定的正则表达式分割字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public char[] toCharArray()&lt;/td&gt;
&lt;td&gt;将字符串转换为字符的数组&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String toLowerCase()&lt;/td&gt;
&lt;td&gt;将所有字符转换为小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String toUpperCase()&lt;/td&gt;
&lt;td&gt;将所有字符转换为大写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String trim()&lt;/td&gt;
&lt;td&gt;去掉头部和尾部的空格&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public static String valueOf( )&lt;/td&gt;
&lt;td&gt;将基本类型、字符数组、对象转换为一个字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;java-lang-stringbuffer和java-lang-stringbuilder&#34;&gt;java.lang.StringBuffer和java.lang.StringBuilder&lt;/h2&gt;

&lt;p&gt;String 对象不可变，添加或插入字符都会创建一个新的对象。&lt;/p&gt;

&lt;h3 id=&#34;stringbuffer和stringbuilder的选择&#34;&gt;StringBuffer和StringBuilder的选择&lt;/h3&gt;

&lt;p&gt;一般用 StringBulider
需要同步选择 StringBuffer&lt;/p&gt;

&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;public int capacity()&lt;/td&gt;
&lt;td&gt;返回对象的容量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public int length()&lt;/td&gt;
&lt;td&gt;返回存储字符串的长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String__ append(String string)&lt;/td&gt;
&lt;td&gt;将string添加到末尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String__ insert (int offset,String string)&lt;/td&gt;
&lt;td&gt;在指定位置插入字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;public String toString()&lt;/td&gt;
&lt;td&gt;返回一个String对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;基本类型包装器&#34;&gt;基本类型包装器&lt;/h1&gt;

&lt;h2 id=&#34;包装类&#34;&gt;包装类&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本类型&lt;/th&gt;
&lt;th&gt;对应包装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;除了Integer和Character类以后，其它类的类名和基本数据类型相同，只是类名首字母大写。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;包装器类的方法&#34;&gt;包装器类的方法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;构造方法&lt;/strong&gt;：&lt;strong&gt;基本类型&lt;/strong&gt; &amp;ndash;&amp;gt; 包装器类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造方法&lt;/strong&gt;：&lt;strong&gt;字符串&lt;/strong&gt; &amp;ndash;&amp;gt; 包装器类&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;带有基本值参数并创建包装类对象的构造函数  &lt;code&gt;Integer obj=new Integer(145);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;带有字符串参数并创建包装类对象的构造函数  &lt;code&gt;Integer obj=new Integer(&amp;quot;-45.36&amp;quot;);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;parse___&lt;/strong&gt;：&lt;strong&gt;字符串&lt;/strong&gt; &amp;ndash;&amp;gt; 基本类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;___Value&lt;/strong&gt;：&lt;strong&gt;包装器类&lt;/strong&gt; &amp;ndash;&amp;gt; 基本类型&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;可生成对象基本值的typeValue方法  &lt;code&gt;obj.intValue();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将字符串转换为基本值的 parseType方法  &lt;code&gt;Integer.parseInt(args[0]);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;toString&lt;/strong&gt;：&lt;strong&gt;包装器类&lt;/strong&gt; &amp;ndash;&amp;gt;字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;___.valueOf&lt;/strong&gt;：&lt;strong&gt;字符串&lt;/strong&gt; &amp;ndash;&amp;gt;包装类&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;自动装箱-拆箱&#34;&gt;自动装箱/拆箱&lt;/h2&gt;

&lt;p&gt;JDK1.5的新特性：自动装箱/拆箱(Autoboxing/unboxing)&lt;/p&gt;

&lt;p&gt;自动装箱
 - 基本类型就自动地封装到与它相似类型的包装中，如：Integer i = 100；
 - 本质上是，编译器编译时自动添加：Integer i = new Integer(100);&lt;/p&gt;

&lt;p&gt;自动拆箱
 - 包装类对象自动转换成基本数据类型。如：int a = new Integer(100);
 - 本质是上，编译器编译时自动添加：int a = new Integer(100).intValue();&lt;/p&gt;

&lt;h2 id=&#34;字符串与基本类型的相互转换&#34;&gt;字符串与基本类型的相互转换&lt;/h2&gt;

&lt;h3 id=&#34;基本类型-字符串&#34;&gt;基本类型 &amp;ndash;&amp;gt; 字符串&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;包装类 的 &lt;code&gt;toString()&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;String类 的 &lt;code&gt;valueOf()&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;空字符串&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt; + 基本类型&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;字符串-基本类型&#34;&gt;字符串 &amp;ndash;&amp;gt; 基本类型&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;包装类的 parseXxx 静态方法&lt;/li&gt;
&lt;li&gt;包装类的 valueOf() 方法转换为基本类型的包装类，自动拆箱&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;java-lang-class&#34;&gt;java.lang.Class&lt;/h1&gt;

&lt;h2 id=&#34;关于&#34;&gt;关于&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;每次 JVM 创建对象时，都会创建一个 java.lang.Class 对象来描述该对象的类型。&lt;/li&gt;
&lt;li&gt;同一个类的所有实例，都共享同一个 Class 对象。&lt;/li&gt;
&lt;li&gt;Class 类没有 public 的构造方法，只能有 JVM 创建.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;获取-class-实例&#34;&gt;获取 Class 实例&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;实例变量 obj.getClass()；&lt;/li&gt;
&lt;li&gt;对象类文件 Object.class；&lt;/li&gt;
&lt;li&gt;Class的静态方法 forName();&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;数组只能用&lt;code&gt;.getClass&lt;/code&gt;，不可以用 &lt;code&gt;.class&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h3 id=&#34;class-forname&#34;&gt;Class.forName()&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;static Class&amp;lt;?&amp;gt; forName(String className)&lt;/td&gt;
&lt;td&gt;Returns the Class object associated with the class or interface with the given string name.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;static Class&amp;lt;?&amp;gt; forName(String name, boolean initialize, ClassLoader loader)&lt;/td&gt;
&lt;td&gt;Returns the Class object associated with the class or interface with the given string name, using the given class loader.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;
- name - 类的全名
- initialize - 表示是否初始化类
- loader - 表示加载时使用的类加载器&lt;/p&gt;

&lt;p&gt;Class.forName(className)实际上是调用Class.forName(className,true, this.getClass().getClassLoader())，默认初始化类，使用默认的类加载器。Class.forName（className）加载类时则已初始化。&lt;/p&gt;

&lt;p&gt;CLass.forName()的作用是要求JVM 查找并加载指定的类。
静态代码段在类加载时执行。&lt;/p&gt;

&lt;h3 id=&#34;newlnstance&#34;&gt;newlnstance()&lt;/h3&gt;

&lt;p&gt;用来创建实例&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;和new 的区别&lt;/strong&gt;
- newlnstance ： 使用时类必须已经加载连接，只能调用无参构造函数
- new ： 可以调用任意公共构造函数&lt;/p&gt;

&lt;p&gt;构造函数调用 newlnstance 可以含参。&lt;/p&gt;

&lt;h3 id=&#34;判断类型&#34;&gt;判断类型&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isAnnotationPresent(Class&amp;lt;? extends Annotation&amp;gt; annotationClass)&lt;/td&gt;
&lt;td&gt;判断指定注解是否存在于该元素上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isArray()&lt;/td&gt;
&lt;td&gt;判断该对象是否表示数组&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isAnnotation()&lt;/td&gt;
&lt;td&gt;判断该对象是否表示注解类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isAnonymousClass()&lt;/td&gt;
&lt;td&gt;當且僅當底層類是匿名類此方法返回true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isAssignableFrom(Class&amp;lt;?&amp;gt; cls)&lt;/td&gt;
&lt;td&gt;判断该对象是否与另一个Class对象相同，或者是他的超类或接口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isInstance(Object obj)&lt;/td&gt;
&lt;td&gt;判断 obj 是否兼容于该 class 对象，即 obj 是否是 class 的自身实例或子类实例&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isInterface()&lt;/td&gt;
&lt;td&gt;判断该对象是否表示接口类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isEnum()&lt;/td&gt;
&lt;td&gt;判断该对象是否表示枚举类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isSynthetic()&lt;/td&gt;
&lt;td&gt;判断该对象是否表示合成类&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isMemberClass()&lt;/td&gt;
&lt;td&gt;判断该对象是否表示内部类/成员类&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isLocalClass()&lt;/td&gt;
&lt;td&gt;判断该对象是否表示局部类&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;isPrimitive()&lt;/td&gt;
&lt;td&gt;判断该对象是否表示基本类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;java-lang-system&#34;&gt;java.lang.System&lt;/h1&gt;

&lt;h1 id=&#34;java-lang-scaner&#34;&gt;java.lang.Scaner&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Java 类与对象</title>
      <link>http://f12998765.github.io/java-notes/java-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://f12998765.github.io/java-notes/java-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</guid>
      <description>

&lt;h2 id=&#34;什么是类&#34;&gt;什么是类？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;类是实体的抽象，对象是类的实例化。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
访问修饰符 class 类名{

 //成员变量

 //构造方法

 //成员方法

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;变量的类型-作用域和生存期&#34;&gt;变量的类型、作用域和生存期&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;th&gt;作用域&lt;/th&gt;
&lt;th&gt;生存期&lt;/th&gt;
&lt;th&gt;初始值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;成员变量&lt;/td&gt;
&lt;td&gt;实体的属性，在类中声明，但是它方法、构造器或者语句块外&lt;/td&gt;
&lt;td&gt;当前类&lt;/td&gt;
&lt;td&gt;随对象的创建而创建， 随对象销毁而销毁&lt;/td&gt;
&lt;td&gt;默认初始值：数字 &amp;ndash; &amp;gt; 0，布尔型 &amp;ndash;&amp;gt; &lt;code&gt;false&lt;/code&gt;，对象引用 &amp;ndash;&amp;gt; null&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;局部变量&lt;/td&gt;
&lt;td&gt;定义在方法、语句块中的变量以及形参&lt;/td&gt;
&lt;td&gt;局部有效&lt;/td&gt;
&lt;td&gt;作用范围结束，就会释放空间&lt;/td&gt;
&lt;td&gt;没有默认初始值，使用时必须赋值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;静态变量 \/ 类变量&lt;/td&gt;
&lt;td&gt;用关键字static修饰的成员变量&lt;/td&gt;
&lt;td&gt;多个对象共享一个变量&lt;/td&gt;
&lt;td&gt;随着类的加载而存在，随着类的消失而消失&lt;/td&gt;
&lt;td&gt;可用类名或对象名访问&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;成员方法&#34;&gt;成员方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;方法是实体的功能实现&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
访问修饰符 返回值类型 函数名(参数类型 参数名) {

 //执行语句

 return 返回值;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法的重载&#34;&gt;方法的重载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相同的方法名，不同参数的类型、参数的个数和参数的顺序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;与方法的重载无关。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;构造方法&#34;&gt;构造方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;在类实例化过程中有且仅调用一次的无返回值方法，对对象进行初始化。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;特点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法名&lt;strong&gt;与类名相同&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不可以显示调用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;不需要&lt;/strong&gt;定义返回值类型，没有返回值&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;a.没有定义构造函数时，会自动生成无参构造函数，否则不会生成。&lt;/p&gt;

&lt;p&gt;b.多个构造函数是重载的体现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;对象&#34;&gt;对象&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;对象是类的实例化&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ClasaName name=new ClassName();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对象的创建 :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;声明变量 &amp;ndash;&amp;gt; 实例化 &amp;ndash;&amp;gt; 初始化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行顺序（优先级从高到低）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;静态代码块&amp;gt;mian方法&amp;gt;构造代码块&amp;gt;构造方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;创建一个对象都在内存中做了什么事情&#34;&gt;创建一个对象都在内存中做了什么事情？&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;加载硬盘中&lt;code&gt;.class&lt;/code&gt; 文件到内存&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;main()&lt;/code&gt;执行时，在栈内存中创建&lt;code&gt;main()&lt;/code&gt;的空间(压栈-入栈)，&lt;code&gt;main()&lt;/code&gt;的栈区中创建变量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;new&lt;/code&gt;在堆内存中创建实体空间&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在实体空间中进行属性的空间分配，并且进行默认初始化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对属性进行显示初始化，即对其赋值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进行实体的构造代码块初始化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用该实体对应的构造函数，进行构造函数初始化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将实体空间首地址赋值给变量，变量就引用了该实体，即指向了该对象&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;代码块&#34;&gt;代码块&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;用{ }封装的多行代码&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码块&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;普通代码块&lt;/td&gt;
&lt;td&gt;方法或语句中出现的代码块&lt;/td&gt;
&lt;td&gt;按顺序执行，最小作用域&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;构造代码块&lt;/td&gt;
&lt;td&gt;在类中的未用static修饰的代码块&lt;/td&gt;
&lt;td&gt;对变量赋值，执行语句。创建对象时执行，早于构造函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;静态代码块&lt;/td&gt;
&lt;td&gt;在类中用static修饰的代码块&lt;/td&gt;
&lt;td&gt;仅会在第一次对象实例化时创建执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
  </channel>
</rss>