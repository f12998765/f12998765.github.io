<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on XIZERO</title>
    <link>http://hugo.xizero.com/categories/java/index.xml</link>
    <description>Recent content in Java on XIZERO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://hugo.xizero.com/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CORS</title>
      <link>http://hugo.xizero.com/javaee/cors/</link>
      <pubDate>Mon, 27 Feb 2017 20:35:59 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/javaee/cors/</guid>
      <description>

&lt;h1 id=&#34;cors&#34;&gt;CORS&lt;/h1&gt;

&lt;p&gt;跨域资源共享 ，Cross-Origin Resource Sharing ，简称 CORS。&lt;/p&gt;

&lt;p&gt;使用 XMLHttpRequest 对象和Fetch发起 HTTP 请求就必须遵守同源策略，CORS 是HTML5 的跨域解决方案。&lt;/p&gt;

&lt;p&gt;了解更多，参阅：&lt;a href=&#34;https://www.w3.org/TR/cors/&#34;&gt;https://www.w3.org/TR/cors/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;关于跨域请求&#34;&gt;关于跨域请求&lt;/h2&gt;

&lt;p&gt;理解上，跨域请求不是被服务器拒绝，而是&lt;strong&gt;返回结果被浏览器拦截&lt;/strong&gt;了，被拒绝的结果可以在浏览器的开发者工具中查看。&lt;/p&gt;

&lt;p&gt;其它，有些浏览器不允许从HTTPS的域跨域访问HTTP，比如Chrome和Firefox，会在请求发出前拦截。&lt;/p&gt;

&lt;p&gt;常用的跨域请求场景是：使用 XMLHttpRequest 或 Fetch发起跨站 HTTP 请求。&lt;/p&gt;

&lt;h2 id=&#34;cors-过程理解&#34;&gt;CORS 过程理解&lt;/h2&gt;

&lt;p&gt;首先明确，&lt;strong&gt;CORS 的关键是服务器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;最简单的过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;浏览器发送 CORS 请求，在 header 中添加一个 &lt;code&gt;Origin&lt;/code&gt; 字段，其值为请求源（协议+地址+端口）&lt;/li&gt;
&lt;li&gt;服务器响应，并在 header 中添加 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 字段&lt;/li&gt;
&lt;li&gt;浏览器接收，判断 header 来确定是否拦截&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;cors-请求&#34;&gt;CORS 请求&lt;/h2&gt;

&lt;p&gt;浏览器将 CORS 请求分为两类，简单请求和预请求。&lt;/p&gt;

&lt;h3 id=&#34;简单请求&#34;&gt;简单请求&lt;/h3&gt;

&lt;p&gt;简单请求的定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只使用 GET, HEAD 或者 POST 请求方法。&lt;/li&gt;
&lt;li&gt;使用 POST  请求时，数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。&lt;/li&gt;
&lt;li&gt;不会使用自定义请求头&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单请求的响应就是最简单的过程，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。&lt;/p&gt;

&lt;h3 id=&#34;预请求&#34;&gt;预请求&lt;/h3&gt;

&lt;p&gt;预请求就是非简单请求。&lt;/p&gt;

&lt;p&gt;预请求的重点是必须发送一个 &lt;code&gt;OPTIONS&lt;/code&gt; 请求，来确定是否支持 CORS。浏览器确认之后，才会发送正式请求。原因是会对服务器的数据造成破坏。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请求过程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发送一个 &lt;code&gt;OPEIONS&lt;/code&gt; 请求。一同发送的还包括三个请求头：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Origin - 源地址&lt;/li&gt;
&lt;li&gt;Access-Control-Request-Method - 跨域请求的 HTTP 方法列表&lt;/li&gt;
&lt;li&gt;Access-Control-Request-Headers - 跨域请求将发送的自定义头信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;服务器处理请求，返回响应。并且返回了相应的响应头：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Access-Control-Allow-Origin&lt;/li&gt;
&lt;li&gt;Access-Control-Allow-Methods&lt;/li&gt;
&lt;li&gt;Access-Control-Allow-Headers&lt;/li&gt;
&lt;li&gt;Access-Control-Allow-Credentials&lt;/li&gt;
&lt;li&gt;Access-Control-Max-Age&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之后的正常请求，与简单请求相同。&lt;/p&gt;

&lt;h2 id=&#34;http-请求头&#34;&gt;HTTP 请求头&lt;/h2&gt;

&lt;h3 id=&#34;origin&#34;&gt;Origin&lt;/h3&gt;

&lt;p&gt;请求的源地址，包含请求的协议，地址，以及端口&lt;/p&gt;

&lt;p&gt;不限于 CORS 请求，普通请求也会携带&lt;/p&gt;

&lt;p&gt;当 Origin 的值为 null 时，表示请求地址为本地&lt;/p&gt;

&lt;h3 id=&#34;access-control-request-method&#34;&gt;Access-Control-Request-Method&lt;/h3&gt;

&lt;p&gt;在发送预请求中携带&lt;/p&gt;

&lt;p&gt;告诉服务器在正式请求时使用的 HTTP 方法&lt;/p&gt;

&lt;h3 id=&#34;access-control-request-headers&#34;&gt;Access-Control-Request-Headers&lt;/h3&gt;

&lt;p&gt;在发送预请求中携带&lt;/p&gt;

&lt;p&gt;告诉服务器在正式请求时会携带的自定义头信息。&lt;/p&gt;

&lt;p&gt;多个值，使用逗号分开&lt;/p&gt;

&lt;h2 id=&#34;http-响应头&#34;&gt;HTTP 响应头&lt;/h2&gt;

&lt;h3 id=&#34;access-control-allow-origin&#34;&gt;Access-Control-Allow-Origin&lt;/h3&gt;

&lt;p&gt;服务器响应的响应&lt;/p&gt;

&lt;p&gt;允许请求的 URL&lt;/p&gt;

&lt;p&gt;当值为 &lt;code&gt;*&lt;/code&gt; 时，接受任意地址的请求&lt;/p&gt;

&lt;h3 id=&#34;access-control-expose-headers&#34;&gt;Access-Control-Expose-Headers&lt;/h3&gt;

&lt;p&gt;允许请求的自定义头&lt;/p&gt;

&lt;h3 id=&#34;access-control-max-age&#34;&gt;Access-Control-Max-Age&lt;/h3&gt;

&lt;p&gt;预请求结果的有效期，在有效期内，发送非简单请求，不需要再发送预请求。&lt;/p&gt;

&lt;h3 id=&#34;access-control-allow-credentials&#34;&gt;Access-Control-Allow-Credentials&lt;/h3&gt;

&lt;p&gt;是否允许发送 Cookie和HTTP认证信息&lt;/p&gt;

&lt;p&gt;首先，在请求中设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;xhr.withCredentials = true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使得 Cookies 能随请求一同发送&lt;/p&gt;

&lt;p&gt;服务器接收响应，在响应头中包含 &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;如果响应头中没有该字段，浏览器会把响应结果丢弃，保证信息安全。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发送 Cookie 时，必须指定允许请求的域名。&lt;/p&gt;

&lt;p&gt;不能设置为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: * 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;access-control-allow-methods&#34;&gt;Access-Control-Allow-Methods&lt;/h3&gt;

&lt;p&gt;在预请求的响应中携带&lt;/p&gt;

&lt;p&gt;在正式请求时可使用的 HTTP 方法&lt;/p&gt;

&lt;h3 id=&#34;access-control-allow-headers&#34;&gt;Access-Control-Allow-Headers&lt;/h3&gt;

&lt;p&gt;在预请求的响应中携带&lt;/p&gt;

&lt;p&gt;在正式请求时可使用的自定义HTTP请求头&lt;/p&gt;

&lt;h2 id=&#34;在服务器端支持-cors&#34;&gt;在服务器端支持 CORS&lt;/h2&gt;

&lt;p&gt;相关信息，参阅 &lt;a href=&#34;https://enable-cors.org/index.html&#34;&gt;enable cross-origin resource sharing&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;在-tomcat-中设置-cors&#34;&gt;在 tomcat 中设置 CORS&lt;/h3&gt;

&lt;p&gt;在项目的 web.xml 中添加过滤器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;CorsFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;org.apache.catalina.filters.CorsFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
  &amp;lt;filter-name&amp;gt;CorsFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多参数，请看 &lt;a href=&#34;http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#CORS_Filter&#34;&gt;http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#CORS_Filter&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;在-nginx-中设置-cors&#34;&gt;在 nginx 中设置 CORS&lt;/h3&gt;

&lt;p&gt;请直接参阅，&lt;a href=&#34;https://enable-cors.org/server_nginx.html&#34;&gt;https://enable-cors.org/server_nginx.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;在-java-web-项目中自定义-cors-过滤器&#34;&gt;在 java web 项目中自定义 CORS 过滤器&lt;/h3&gt;

&lt;p&gt;一个简单的 CORS 过滤器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.x.filter;
import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;

@Component
public class SimpleCORSFilter implements Filter {

    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) res;
        response.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;);
        response.setHeader(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, &amp;quot;true&amp;quot;);
        response.setHeader(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;POST, GET, OPTIONS, DELETE&amp;quot;);
        response.setHeader(&amp;quot;Access-Control-Max-Age&amp;quot;, &amp;quot;3600&amp;quot;);
        response.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers,Authorization&amp;quot;);
        chain.doFilter(req, res);
    }

    public void init(FilterConfig filterConfig) {}

    public void destroy() {}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记得在 web.xml 中配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;!--CORS 过滤器--&amp;gt;
  &amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;CORSFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;com.x.filter.SimpleCORSFilter&amp;lt;/filter-class&amp;gt;
  &amp;lt;/filter&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;CORSFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/04/cors.html&#34;&gt;跨域资源共享 CORS 详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.w3.org/TR/cors/&#34;&gt;https://www.w3.org/TR/cors/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swagger</title>
      <link>http://hugo.xizero.com/javaee/swagger/</link>
      <pubDate>Mon, 27 Feb 2017 20:34:55 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/javaee/swagger/</guid>
      <description>

&lt;h1 id=&#34;swagger&#34;&gt;Swagger&lt;/h1&gt;

&lt;p&gt;官网：&lt;a href=&#34;http://swagger.io/&#34;&gt;http://swagger.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Github：&lt;a href=&#34;https://github.com/swagger-api&#34;&gt;https://github.com/swagger-api&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;THE WORLD&amp;rsquo;S MOST POPULAR API FRAMEWORK&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;世界上最流行的API框架&lt;/p&gt;

&lt;p&gt;Swagger is a powerful open source framework backed by a large ecosystem of tools that helps you design, build, document, and consume your RESTful APIs.&lt;/p&gt;

&lt;p&gt;Swagger是一个强大的开源框架，有工具生态系统支持，可帮助您设计，构建，记录和使用RESTful API。&lt;/p&gt;

&lt;p&gt;Swagger 官方提供了三个工具，分别用于 Design、Build和Document：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Swagger Editor

&lt;ul&gt;
&lt;li&gt;一个设计或编辑 API 的编辑器，能根据 Swagger 规范进行直观的反馈。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Swagger Codegen

&lt;ul&gt;
&lt;li&gt;将 Swagger 文档转换成代码。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Swagger UI

&lt;ul&gt;
&lt;li&gt;在浏览器中浏览测试 REST API 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;swagger-editor&#34;&gt;Swagger Editor&lt;/h2&gt;

&lt;p&gt;Swagger Editor 是一个可视化的 API 编辑器，能根据 Swagger 规范实时校验文档。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ox.xizero.com/uploads/2017/02/swagger_editor.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;Swagger 提供了在线版的 Swagger Editor ：&lt;a href=&#34;http://editor.swagger.io/#/&#34;&gt;http://editor.swagger.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;也可以在 Github 上下载项目，在本地服务器（Nginx 或 npm http-server）上运行。&lt;/p&gt;

&lt;p&gt;Github地址：&lt;a href=&#34;https://github.com/swagger-api/swagger-editor&#34;&gt;https://github.com/swagger-api/swagger-editor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;也可以直接在拉取 docker 镜像，运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker pull swaggerapi/swagger-editor
docker run -p 80:8080 swaggerapi/swagger-editor
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;Swagger 的文档需要符合 OpenAPI Specification ，使用 json 或者 yaml 描述 API。&lt;/p&gt;

&lt;h3 id=&#34;openapi-specification&#34;&gt;OpenAPI Specification&lt;/h3&gt;

&lt;p&gt;查看官方文档之前，推荐阅读：&lt;a href=&#34;https://www.gitbook.com/book/huangwenchao/swagger/details&#34;&gt;《如何编写基于OpenAPI规范的API文档》&lt;/a&gt;，可以对文档结构有个了解。&lt;/p&gt;

&lt;p&gt;官方文档：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Swagger 官网上的：&lt;a href=&#34;http://swagger.io/specification/&#34;&gt;http://swagger.io/specification/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github上的：&lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md&#34;&gt;https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;国内关于 Swagger 的中文文档较少，简单地翻译了一下  OpenAPI Specification ，水平有限，见谅！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OpenAPI Specification 中文：&lt;a href=&#34;https://www.xizero.com/mixin/OpenAPISpecificationZh/&#34;&gt;https://www.xizero.com/mixin/OpenAPISpecificationZh/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Arnaud Lauret 大神的 OpenAPI Specification Visual Documentation ，可以对文档结构有个清晰了解。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OpenAPI Specification Visual Documentation：&lt;a href=&#34;http://openapi-specification-visual-documentation.apihandyman.io/&#34;&gt;http://openapi-specification-visual-documentation.apihandyman.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在 Github 上开源地址：&lt;a href=&#34;https://github.com/arno-di-loreto/openapi-specification-visual-documentation&#34;&gt;https://github.com/arno-di-loreto/openapi-specification-visual-documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并且大神在其博客上写了一个系列教程：Writing OpenAPI (fka Swagger) Specification tutorial&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大神的博客：&lt;a href=&#34;http://apihandyman.io/&#34;&gt;API Handyman - http://apihandyman.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;教程的地址：&lt;a href=&#34;http://apihandyman.io/writing-openapi-swagger-specification-tutorial-part-1-introduction/&#34;&gt;http://apihandyman.io/writing-openapi-swagger-specification-tutorial-part-1-introduction/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;相关&#34;&gt;相关&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JSON Schema&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官网：&lt;a href=&#34;http://json-schema.org/&#34;&gt;http://json-schema.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github：&lt;a href=&#34;https://github.com/json-schema-org/json-schema-spec&#34;&gt;https://github.com/json-schema-org/json-schema-spec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;YAML&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Official YAML Web Site：&lt;a href=&#34;http://www.yaml.org/&#34;&gt;http://www.yaml.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;阮一峰-YAML 语言教程：&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/07/yaml.html&#34;&gt;http://www.ruanyifeng.com/blog/2016/07/yaml.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Google Java Style Guide&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://google.github.io/styleguide/javaguide.html&#34;&gt;https://google.github.io/styleguide/javaguide.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://huangwenchao.gitbooks.io/swagger/content/&#34;&gt;如何编写基于OpenAPI规范的API文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swagger.io/specification/&#34;&gt;SWAGGER SPECIFICATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/arno-di-loreto/openapi-specification-visual-documentation&#34;&gt;OpenAPI Specification Visual Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;swagger-codegen&#34;&gt;Swagger Codegen&lt;/h2&gt;

&lt;p&gt;Swagger Codegen 是一个代码生成工具，根据符合 Swagger 规范的 API 文档生成 API clients 、Server stubs 或者其他类型的文档，还有其他(JMeter)。支持的语言/框架，如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;API clients: ActionScript, Bash, C# (.net 2.0, 4.0 or later), C++ (cpprest, Qt5, Tizen), Clojure, Dart, Elixir, Go, Groovy, Haskell, Java (Jersey1.x, Jersey2.x, OkHttp, Retrofit1.x, Retrofit2.x, Feign), Node.js (ES5, ES6, AngularJS with Google Closure Compiler annotations) Objective-C, Perl, PHP, Python, Ruby, Scala, Swift (2.x, 3.x), Typescript (Angular1.x, Angular2.x, Fetch, Node)&lt;/li&gt;
&lt;li&gt;Server stubs: C# (ASP.NET Core, NancyFx), Erlang, Go, Haskell, Java (MSF4J, Spring, Undertow, JAX-RS: CDI, CXF, Inflector, RestEasy), PHP (Lumen, Slim, Silex, Zend Expressive), Python (Flask), NodeJS, Ruby (Sinatra, Rails5), Scala (Finch, Scalatra)&lt;/li&gt;
&lt;li&gt;API documentation generators: HTML, Confluence Wiki&lt;/li&gt;
&lt;li&gt;Others: JMeter&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装-1&#34;&gt;安装&lt;/h2&gt;

&lt;h3 id=&#34;环境要求&#34;&gt;环境要求&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Java 7 or 8&lt;/li&gt;
&lt;li&gt;Apache maven 3.3.3 or greater&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装及配置环境，可以看  &lt;a href=&#34;https://www.xizero.com/tool/Java%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%81%A2%E5%A4%8D%E6%89%8B%E5%86%8C/&#34;&gt;《Java 开发环境恢复手册》&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;下载&#34;&gt;下载&lt;/h3&gt;

&lt;p&gt;本地环境是 win10 ，关于&lt;a href=&#34;https://github.com/swagger-api/swagger-codegen#os-x-users&#34;&gt; OS X&lt;/a&gt;、&lt;a href=&#34;https://github.com/swagger-api/swagger-codegen#docker&#34;&gt;docker&lt;/a&gt;下的使用，暂不了解。&lt;/p&gt;

&lt;p&gt;可以下载项目，自己编译运行，也可以直接下载 jar 文件执行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;克隆编译，生成的 &lt;code&gt;swagger-codegen-cli.jar&lt;/code&gt; 文件在 &lt;code&gt;modules/swagger-codegen-cli/target/&lt;/code&gt; 下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/swagger-api/swagger-codegen cd swagger
 -codegen 
mvn clean package 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;直接下载

&lt;ul&gt;
&lt;li&gt;Github ：&lt;a href=&#34;https://github.com/swagger-api/swagger-codegen/releases&#34;&gt;https://github.com/swagger-api/swagger-codegen/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Maven ：&lt;a href=&#34;https://mvnrepository.com/artifact/io.swagger/swagger-codegen&#34;&gt;https://mvnrepository.com/artifact/io.swagger/swagger-codegen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-1&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;编译生成的 &lt;code&gt;swagger-codegen-cli.jar&lt;/code&gt; 文件在 &lt;code&gt;modules/swagger-codegen-cli/target/&lt;/code&gt; 下 ，使用时要注意路径。&lt;/p&gt;

&lt;p&gt;而且克隆项目下的 &lt;code&gt;bin&lt;/code&gt; 目录中有很多脚本，可以很方便地使用。初学的话，也可以借鉴很多。&lt;/p&gt;

&lt;p&gt;下面，解释一下相关的命令：&lt;/p&gt;

&lt;h4 id=&#34;java-jar-swagger-codegen-cli-2-2-1-jar-help&#34;&gt;&lt;code&gt;java -jar swagger-codegen-cli-2.2.1.jar help&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;查看帮助信息&lt;/p&gt;

&lt;p&gt;命令格式：&lt;code&gt;swagger-codegen-cli &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意在 win 下使用，应该是 &lt;code&gt;java -jar swagger-codegen-cli-2.2.1.jar  &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]&lt;/code&gt;，其他地方相同不另做声明&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以使用 &lt;code&gt;swagger-codegen-cli help &amp;lt;command&amp;gt;&lt;/code&gt; 查看相关命令的更多信息。&lt;/p&gt;

&lt;p&gt;常用的命令：
- config-help&lt;br /&gt;
    - 所选语言的配置帮助
- generate&lt;br /&gt;
    - 生成所选语言的代码
- help&lt;br /&gt;
    - 显示帮助信息
- langs&lt;br /&gt;
    - 显示支持的语言
- meta&lt;br /&gt;
    - MetaGenerator. Generator for creating a new template set and configuration for Co the language you specify, and includes default templates to include.
    - 用于自定义模板，暂不了解&lt;/p&gt;

&lt;h4 id=&#34;config-help&#34;&gt;&lt;code&gt;config-help&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;查看 &lt;code&gt;config-help&lt;/code&gt; 命令的使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;`java -jar swagger-codegen-cli-2.2.1.jar help config-help`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config-help&lt;/code&gt; 命令格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;swagger-codegen-cli config-help (-l &amp;lt;language&amp;gt; | --lang &amp;lt;language&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config-help&lt;/code&gt; 命令参数：
- language - 所选语言&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config-help&lt;/code&gt; 命令样例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar swagger-codegen-cli-2.2.1.jar config-help -l spring
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取 &lt;code&gt;spring&lt;/code&gt; 的配置帮助，注意 &lt;code&gt;spring&lt;/code&gt; 的默认模板是 &lt;code&gt;spring-boot&lt;/code&gt;，若要生成 &lt;code&gt;spring-mvc&lt;/code&gt; ，需要在 &lt;code&gt;generate&lt;/code&gt; 中指定 &lt;code&gt;library&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 部分执行结果
library
    library template (sub-template) to use (Default: spring-boot)
        spring-boot - Spring-boot Server application using the SpringFox integration.
        spring-mvc - Spring-MVC Server application using the SpringFox integration.
        spring-cloud - Spring-Cloud-Feign client with Spring-Boot auto-configured settings.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;langs&#34;&gt;&lt;code&gt;langs&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;查看支持的语言和框架&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar swagger-codegen-cli-2.2.1.jar langs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果&lt;/p&gt;

&lt;p&gt;Available languages: [android, aspnet5, async-scala, cwiki, csharp, cpprest, dart, flash, python-flask, go, groovy, java, jaxrs, jaxrs-cxf, jaxrs-resteasy, jaxrs-spec, inflector, javascript, javascript-closure-angular, jmeter, nancyfx, nodejs-server, objc, perl, php, python, qt5cpp, ruby, scala, scalatra, silex-PHP, sinatra, rails5, slim, spring, dynamic-html, html, html2, swagger, swagger-yaml, swift, tizen, typescript-angular2, typescript-angular, typescript-node, typescript-fetch, akka-scala, CsharpDotNet2, clojure, haskell, lumen, go-server]&lt;/p&gt;

&lt;p&gt;了解相关语言的配置帮助，可使用 &lt;code&gt;config-help&lt;/code&gt; 命令。&lt;/p&gt;

&lt;h4 id=&#34;generate&#34;&gt;&lt;code&gt;generate&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;generate&lt;/code&gt; 的作用是根据 API 文档生成代码，是&lt;strong&gt;最重要的命令&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;首先查看 &lt;code&gt;generate&lt;/code&gt; 命令的帮助信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ java -jar swagger-codegen-cli-2.2.1.jar help generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;概要，参数 &lt;code&gt;-i&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 是必要参数，其他参数可选。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;swagger-codegen-cli generate
        [(-a &amp;lt;authorization&amp;gt; | --auth &amp;lt;authorization&amp;gt;)]
        [--additional-properties &amp;lt;additional properties&amp;gt;]
        [--api-package &amp;lt;api package&amp;gt;] [--artifact-id &amp;lt;artifact id&amp;gt;]
        [--artifact-version &amp;lt;artifact version&amp;gt;]
        [(-c &amp;lt;configuration file&amp;gt; | --config &amp;lt;configuration file&amp;gt;)]
        [-D &amp;lt;system properties&amp;gt;] [--git-repo-id &amp;lt;git repo id&amp;gt;]
        [--git-user-id &amp;lt;git user id&amp;gt;] [--group-id &amp;lt;group id&amp;gt;]
        [--http-user-agent &amp;lt;http user agent&amp;gt;]
        (-i &amp;lt;spec file&amp;gt; | --input-spec &amp;lt;spec file&amp;gt;)
        [--import-mappings &amp;lt;import mappings&amp;gt;]
        [--instantiation-types &amp;lt;instantiation types&amp;gt;]
        [--invoker-package &amp;lt;invoker package&amp;gt;]
        (-l &amp;lt;language&amp;gt; | --lang &amp;lt;language&amp;gt;)
        [--language-specific-primitives &amp;lt;language specific primitives&amp;gt;]
        [--library &amp;lt;library&amp;gt;] [--model-name-prefix &amp;lt;model name prefix&amp;gt;]
        [--model-name-suffix &amp;lt;model name suffix&amp;gt;]
        [--model-package &amp;lt;model package&amp;gt;]
        [(-o &amp;lt;output directory&amp;gt; | --output &amp;lt;output directory&amp;gt;)]
        [--release-note &amp;lt;release note&amp;gt;] [(-s | --skip-overwrite)]
        [(-t &amp;lt;template directory&amp;gt; | --template-dir &amp;lt;template directory&amp;gt;)]
        [--type-mappings &amp;lt;type mappings&amp;gt;] [(-v | --verbose)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;部分参数解释&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-i &amp;lt;spec file&amp;gt;, --input-spec &amp;lt;spec file&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;必须&lt;/strong&gt; Swagger 规范文件的位置，可以是 url 也可以是文件的路径。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l &amp;lt;language&amp;gt;, --lang &amp;lt;language&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;必须&lt;/strong&gt; 所选的语言或框架&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-o &amp;lt;output directory&amp;gt;, --output &amp;lt;output directory&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;生成项目的位置，默认是当前目录&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--library &amp;lt;library&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指定子模板，库模板&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-c &amp;lt;configuration file&amp;gt;, --config &amp;lt;configuration file&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置配置文件的路径，文件格式为 json ，如 &lt;code&gt;{&amp;quot;optionKey&amp;quot;:&amp;quot;optionValue&amp;quot;, &amp;quot;optionKey1&amp;quot;:&amp;quot;optionValue1&amp;quot;...}&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;不同语言的配置信息不同，使用 &lt;code&gt;config-help -l {lang}&lt;/code&gt; 了解更多。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--api-package &amp;lt;api package&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置 api 类的包名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--artifact-id &amp;lt;artifact id&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置 pom.xml 中的 artifactId&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--artifact-version &amp;lt;artifact version&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置生成 pom.xml 中的 artifact version&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--model-package &amp;lt;model package&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置 models 的包名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--model-name-prefix &amp;lt;model name prefix&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;model 的前缀，默认为空字符串&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--model-name-suffix &amp;lt;model name suffix&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;model 的后缀，默认为空字符串&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--instantiation-types &amp;lt;instantiation types&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置实例化类型的映射。格式为 &lt;code&gt;type=instantiatedType&lt;/code&gt;，多个映射之间用逗号 &lt;code&gt;,&lt;/code&gt; 隔开。&lt;/p&gt;

&lt;p&gt;java 的一个例子: &lt;code&gt;array=ArrayList,map=HashMap&lt;/code&gt;，&lt;code&gt;array&lt;/code&gt; 类型在生成的代码中会实例化为 &lt;code&gt;ArrayList&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--type-mappings &amp;lt;type mappings&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设置swagger规范类型和生成的代码类型之间的映射。例如 &lt;code&gt;array=List,map=Map,string=String&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;不了解 &lt;code&gt;instantiation-types&lt;/code&gt; 和 &lt;code&gt;type-mappings&lt;/code&gt; 的区别，待解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;样例：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Github wiki 上的 &lt;a href=&#34;https://github.com/swagger-api/swagger-codegen/wiki/Server-stub-generator-HOWTO&#34;&gt;《Server stub generator HOWTO》&lt;/a&gt;，列举了生成多种语言框架 server 的命令。但是一些并不那么好使，比如 spring-mvc。&lt;/p&gt;

&lt;p&gt;wiki 例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \
  -i http://petstore.swagger.io/v2/swagger.json \
  -l spring-mvc \
  -o samples/server/petstore/spring-mvc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是实际上，在 Swagger codegen v2.2.0 中 spring-mvc 被删掉了，但是作为了 spring 的一个非默认库，spring-boot 作为其默认库。&lt;/p&gt;

&lt;p&gt;具体细节&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更新日志 &lt;a href=&#34;https://github.com/swagger-api/swagger-codegen/releases/tag/v2.2.0&#34;&gt;https://github.com/swagger-api/swagger-codegen/releases/tag/v2.2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/swagger-api/swagger-codegen/pull/3133&#34;&gt;[Spring] put spring-mvc and spring-boot under the same language gen #3133&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在创建 spring-mvc ，应该这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar swagger-codegen-cli-2.2.1.jar generate -i swagger.yaml -l spring --library spring-mvc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;swagger-codegen-总结&#34;&gt;Swagger codegen 总结&lt;/h3&gt;

&lt;p&gt;Swagger codegen 作用就是根据 json 或 yaml 格式的 API 文档来生成代码。&lt;/p&gt;

&lt;p&gt;基本掌握级别是会使用 &lt;code&gt;generate&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;其他进阶，如自定义模板、添加新的语言框架、工作流集成等等，可以看Github 上的 &lt;a href=&#34;https://github.com/swagger-api/swagger-codegen/blob/master/README.md&#34;&gt;README&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/swagger-api/swagger-codegen/wiki&#34;&gt;wiki&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然最简单的生成，可以在 Swagger Editore 中使用 Generate Server 和 Generate Client。只是不如命令操作仔细。还有，在 Swagger codegen 的 Github 项目中 &lt;code&gt;bin&lt;/code&gt; 目录下有很多可用的脚本，可根据需要修改使用。&lt;/p&gt;

&lt;h3 id=&#34;参考-1&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/swagger-api/swagger-codegen&#34;&gt;Swagger Codegen Gtihub 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/swagger-api/swagger-codegen/wiki&#34;&gt;Swagger Codegen Gtihub Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://javaarm.com/faces/display.xhtml;jsessionid=dkH9tZqNyijEI4XCAbpWtmV0?tid=3915&#34;&gt;Swagger Code Generator v2.1.5 README 中文翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/swagger-api/swagger-codegen/pull/3133&#34;&gt;[Spring] put spring-mvc and spring-boot under the same language gen #3133&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/wangjunjun2008/article/details/53200437&#34;&gt;swagger-codegen生成java客户端代码（其他语言类似）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;swagger-ui&#34;&gt;Swagger UI&lt;/h2&gt;

&lt;p&gt;Swagger UI  将 API 文档在浏览器中可视化。&lt;/p&gt;

&lt;p&gt;官方的 Demo ，地址：&lt;a href=&#34;http://petstore.swagger.io/&#34;&gt;http://petstore.swagger.io/&lt;/a&gt;。截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ox.xizero.com/uploads/2017/02/swagger_ui.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装-2&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;可以从 &lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34;&gt;Github&lt;/a&gt; 下载项目，打开 &lt;code&gt;./dist/index.html&lt;/code&gt; 直接运行。&lt;/p&gt;

&lt;p&gt;关于 &lt;code&gt;Build&lt;/code&gt; 项目和在 &lt;code&gt;docker&lt;/code&gt;  中运行，暂不了解。&lt;/p&gt;

&lt;p&gt;可以编辑 &lt;code&gt;index.html&lt;/code&gt; ，对 &lt;code&gt;swaggerUi&lt;/code&gt; 对象自定义属性。&lt;/p&gt;

&lt;p&gt;相关属性，参阅 ： &lt;a href=&#34;https://github.com/swagger-api/swagger-ui#swaggerui&#34;&gt;https://github.com/swagger-api/swagger-ui#swaggerui&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;重要属性解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;url  设置默认文档路径&lt;/li&gt;
&lt;li&gt;docExpansion 控制列表显示：默认 none - 完全隐藏；list - 显示路径的操作列表；full - 完全展开&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;中文翻译设置，在 &lt;code&gt;index.html&lt;/code&gt; 中 30 行左右，去掉注释代码，修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&#39;lang/translator.js&#39; type=&#39;text/javascript&#39;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&#39;lang/zh-cn.js&#39; type=&#39;text/javascript&#39;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cors-支持&#34;&gt;CORS 支持&lt;/h3&gt;

&lt;p&gt;关于 CORS 请看另一篇。&lt;/p&gt;

&lt;h3 id=&#34;参考-2&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34;&gt;https://github.com/swagger-api/swagger-ui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;学习-swagger-的总结&#34;&gt;学习 Swagger 的总结&lt;/h2&gt;

&lt;p&gt;Saggger 是世界上最流行的的 API 框架，提供了 API 设计、构建和展示的工具。但是相关的资料也有限，大概入了个门。&lt;/p&gt;

&lt;p&gt;关于 Swagger 的更多相关开源项目，可以在 &lt;a href=&#34;http://swagger.io/open-source-integrations/&#34;&gt;http://swagger.io/open-source-integrations/&lt;/a&gt; 查看。&lt;/p&gt;

&lt;p&gt;下一篇，学习如何从代码生成 API 文档 - SPringFox。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SLF4J 和 Logback</title>
      <link>http://hugo.xizero.com/javaee/SLF4JANDLogback/</link>
      <pubDate>Sun, 19 Feb 2017 15:54:31 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/javaee/SLF4JANDLogback/</guid>
      <description>

&lt;h1 id=&#34;slf4j-simple-logging-facade-for-java&#34;&gt;SLF4J - - Simple Logging Facade for Java&lt;/h1&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://www.slf4j.org/&#34;&gt;https://www.slf4j.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;Hello World&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Slf4jTest {  
    static private Logger logger = LoggerFactory.getLogger(Slf4jTest.class);  
    public static void main(String[] args) {  
        logger.info(&amp;quot;Hello World {}&amp;quot;,&amp;quot;!&amp;quot;)  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多推荐阅读 ：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/wangxindong/blog/825066&#34;&gt;门面之下，日志之上-SLF4J&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/?x=0&amp;amp;y=0&amp;amp;s=slf4j&#34;&gt;并发编程网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;logback&#34;&gt;Logback&lt;/h1&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://logback.qos.ch/&#34;&gt;https://logback.qos.ch/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;logback分为三个模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;logback-core

&lt;ul&gt;
&lt;li&gt;为其他两个模块打下了基础&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;logback-classic

&lt;ul&gt;
&lt;li&gt;可以被看做个有显著改进的log4J&lt;/li&gt;
&lt;li&gt;实现了 SLF4J API&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;logback-access

&lt;ul&gt;
&lt;li&gt;​​与Servlet容器（例如Tomcat和Jetty）集成，以提供HTTP访问日志功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;日志级别&#34;&gt;日志级别&lt;/h2&gt;

&lt;p&gt;原地址：&lt;a href=&#34;https://zh.wikipedia.org/wiki/Log4j&#34;&gt;https://zh.wikipedia.org/wiki/Log4j&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;常用级别由低到高，依次为 Trace &amp;lt; Debug &amp;lt; Tnfo &amp;lt; Warn &amp;lt; Error&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;OFF&lt;/td&gt;
&lt;td&gt;最高级别，用于关闭日志记录。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FATAL&lt;/td&gt;
&lt;td&gt;导致应用程序提前终止的严重错误。一般这些信息将立即呈现在状态控制台上。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ERROR&lt;/td&gt;
&lt;td&gt;其他运行时错误或意外情况。一般这些信息将立即呈现在状态控制台上。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WARN&lt;/td&gt;
&lt;td&gt;使用已过时的API，API的滥用，潜在错误，其他不良的或意外的运行时的状况（但不一定是错误的）。一般这些信息将立即呈现在状态控制台上。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;INFO&lt;/td&gt;
&lt;td&gt;令人感兴趣的运行时事件（启动/关闭）。一般这些信息将立即呈现在状态控制台上，因而要保守使用，并保持到最低限度。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DEBUG&lt;/td&gt;
&lt;td&gt;流经系统的详细信息。一般这些信息只记录到日志文件中。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;最详细的信息。一般这些信息只记录到日志文件中。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;logback-xml-配置&#34;&gt;logback.xml 配置&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ox.xizero.com/uploads/2017/02/Logback.xml.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h3 id=&#34;1-pox-xml-添加依赖&#34;&gt;1.pox.xml 添加依赖&lt;/h3&gt;

&lt;p&gt;仓库地址：&lt;a href=&#34;https://mvnrepository.com/artifact/ch.qos.logback/logback-classic&#34;&gt;https://mvnrepository.com/artifact/ch.qos.logback/logback-classic&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- 使用求值表达式过滤，需要添加 janino 依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.codehaus.janino&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;janino&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-src-main-resource添加logback-xml&#34;&gt;2.src/main/resource添加logback.xml&lt;/h3&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://gist.githubusercontent.com/f12998765/28613af391c72c8c8ba47a0cef3f8250/raw/d1af5d48490308dd80645f9721e1af2b7cd6f69f/logback.xml&#34;&gt;logback.xml&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
        &amp;lt;!-- 项目名称 --&amp;gt;
        &amp;lt;contextName&amp;gt;Test contextName&amp;lt;/contextName&amp;gt;

        &amp;lt;!-- 变量 --&amp;gt;
        &amp;lt;property name=&amp;quot;log&amp;quot; value=&amp;quot;./log&amp;quot;/&amp;gt;

        &amp;lt;!-- 时间戳 --&amp;gt;
        &amp;lt;timestamp key=&amp;quot;bySecond&amp;quot; datePattern=&amp;quot;yyyyMMdd&amp;quot; timeReference=&amp;quot;contextBirth&amp;quot;/&amp;gt;

        &amp;lt;!-- 在控制台打印日志 --&amp;gt;
        &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;

                &amp;lt;!-- 级别过滤器 --&amp;gt;
                &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&amp;gt;
                        &amp;lt;level&amp;gt;DEBUG&amp;lt;/level&amp;gt;
                        &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
                        &amp;lt;onMismatch&amp;gt;NEUTRAL&amp;lt;/onMismatch&amp;gt;
                &amp;lt;/filter&amp;gt;

                &amp;lt;!-- 临界值过滤器 --&amp;gt;
                &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&amp;gt;
                        &amp;lt;level&amp;gt;INFO&amp;lt;/level&amp;gt;
                        &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
                        &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
                &amp;lt;/filter&amp;gt;


                &amp;lt;!-- 求值过滤器 --&amp;gt;
                &amp;lt;filter class=&amp;quot;ch.qos.logback.core.filter.EvaluatorFilter&amp;quot;&amp;gt;
                        &amp;lt;evaluator&amp;gt;
                                &amp;lt;matcher&amp;gt;
                                        &amp;lt;name&amp;gt;num&amp;lt;/name&amp;gt;
                                        &amp;lt;regex&amp;gt;\ba\w*\b&amp;lt;/regex&amp;gt;
                                &amp;lt;/matcher&amp;gt;
                                &amp;lt;expression&amp;gt; num.matches(formattedMessage) &amp;lt;/expression&amp;gt;
                        &amp;lt;/evaluator&amp;gt;
                        &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
                        &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
                &amp;lt;/filter&amp;gt;

                &amp;lt;encoder&amp;gt;
                        &amp;lt;!-- pattern模式 %d时间 %thread 线程名 %level行为级别 %logger logger名称 %method 方法名称 %message 调用方法的入参消息 --&amp;gt;
                        &amp;lt;pattern&amp;gt;%-4d [%thread] %highlight%-5level %cyan%logger.%-10method - %message%n&amp;lt;/pattern&amp;gt;
                &amp;lt;/encoder&amp;gt;
        &amp;lt;/appender&amp;gt;

        &amp;lt;!-- FileAppender 输出到文件 --&amp;gt;
        &amp;lt;appender name=&amp;quot;FILE&amp;quot; class=&amp;quot;ch.qos.logback.core.FileAppender&amp;quot;&amp;gt;

                &amp;lt;file&amp;gt;${log}/log-${bySecond}.log&amp;lt;/file&amp;gt;

                &amp;lt;encoder&amp;gt;
                        &amp;lt;pattern&amp;gt;%date %level [%thread] %logger{30} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
                &amp;lt;/encoder&amp;gt;
        &amp;lt;/appender&amp;gt;


        &amp;lt;!-- 滚动记录日志文件 --&amp;gt;
        &amp;lt;!-- 按时间滚动 --&amp;gt;
        &amp;lt;appender name=&amp;quot;FILE&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
                &amp;lt;file&amp;gt;${log}/test_log.log&amp;lt;/file&amp;gt;
                &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
                        &amp;lt;!-- daily rollover --&amp;gt;
                        &amp;lt;fileNamePattern&amp;gt;${log}/log.%d{yyyy-MM-dd}.log&amp;lt;/fileNamePattern&amp;gt;

                        &amp;lt;!-- keep 30 days&#39; worth of history capped at 3GB total size --&amp;gt;
                        &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
                        &amp;lt;totalSizeCap&amp;gt;3GB&amp;lt;/totalSizeCap&amp;gt;
                &amp;lt;/rollingPolicy&amp;gt;

                &amp;lt;encoder&amp;gt;
                        &amp;lt;pattern&amp;gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&amp;lt;/pattern&amp;gt;
                &amp;lt;/encoder&amp;gt;
        &amp;lt;/appender&amp;gt;

        &amp;lt;!-- Size and time based rolling policy --&amp;gt;
        &amp;lt;appender name=&amp;quot;ROLLING&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
                &amp;lt;file&amp;gt;${log}/test_log.log&amp;lt;/file&amp;gt;
                &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&amp;quot;&amp;gt;
                        &amp;lt;!-- rollover daily --&amp;gt;
                        &amp;lt;fileNamePattern&amp;gt;${log}/log.%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
                        &amp;lt;!-- each file should be at most 100MB, keep 60 days worth of history, but at most 20GB --&amp;gt;
                        &amp;lt;maxFileSize&amp;gt;100MB&amp;lt;/maxFileSize&amp;gt;    
                        &amp;lt;maxHistory&amp;gt;60&amp;lt;/maxHistory&amp;gt;
                        &amp;lt;totalSizeCap&amp;gt;20GB&amp;lt;/totalSizeCap&amp;gt;
                &amp;lt;/rollingPolicy&amp;gt;
                &amp;lt;encoder&amp;gt;
                        &amp;lt;pattern&amp;gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&amp;lt;/pattern&amp;gt;
                &amp;lt;/encoder&amp;gt;
        &amp;lt;/appender&amp;gt;

        &amp;lt;!-- 按窗口滚动 --&amp;gt;
        &amp;lt;appender name=&amp;quot;FILE&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
                &amp;lt;file&amp;gt;${log}/test_log.log&amp;lt;/file&amp;gt;

                &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&amp;quot;&amp;gt;
                        &amp;lt;fileNamePattern&amp;gt;${log}/log.%i.log.zip&amp;lt;/fileNamePattern&amp;gt;
                        &amp;lt;minIndex&amp;gt;1&amp;lt;/minIndex&amp;gt;
                        &amp;lt;maxIndex&amp;gt;3&amp;lt;/maxIndex&amp;gt;
                &amp;lt;/rollingPolicy&amp;gt;

                &amp;lt;triggeringPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&amp;quot;&amp;gt;
                        &amp;lt;maxFileSize&amp;gt;5MB&amp;lt;/maxFileSize&amp;gt;
                &amp;lt;/triggeringPolicy&amp;gt;

                &amp;lt;encoder&amp;gt;
                        &amp;lt;pattern&amp;gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&amp;lt;/pattern&amp;gt;
                &amp;lt;/encoder&amp;gt;
        &amp;lt;/appender&amp;gt;


        &amp;lt;!-- logger --&amp;gt;
        &amp;lt;logger name=&amp;quot;log.test&amp;quot; level=&amp;quot;INFO&amp;quot; additivity=&amp;quot;false&amp;quot;&amp;gt;
                &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot;/&amp;gt;
                &amp;lt;appender-ref ref=&amp;quot;ROLLINGFILE&amp;quot;/&amp;gt;
                &amp;lt;appender-ref ref=&amp;quot;HTMLFILE&amp;quot;/&amp;gt;
        &amp;lt;/logger&amp;gt;

        &amp;lt;logger name=&amp;quot;log.test.Tesg&amp;quot; level=&amp;quot;debug&amp;quot; additivity=&amp;quot;false&amp;quot;&amp;gt;
                &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot;/&amp;gt;
                &amp;lt;appender-ref ref=&amp;quot;ROLLINGFILE&amp;quot;/&amp;gt;
                &amp;lt;appender-ref ref=&amp;quot;HTMLFILE&amp;quot;/&amp;gt;
        &amp;lt;/logger&amp;gt;

        &amp;lt;root level=&amp;quot;debug&amp;quot;&amp;gt;
                &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot;/&amp;gt;
        &amp;lt;/root&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;h3 id=&#34;时间滚动&#34;&gt;时间滚动&lt;/h3&gt;

&lt;p&gt;TimeBasedRollingPolicy 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责触发滚动&lt;/p&gt;

&lt;h3 id=&#34;日期相关&#34;&gt;日期相关&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;年代标志符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;年&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;月&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;日&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;时 在上午或下午 (1~12)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;时 在一天中 (0~23)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;分&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;毫秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;星期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;一年中的第几天&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;一月中第几个星期几&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;一年中第几个星期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;一月中第几个星期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;上午 / 下午 标记符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;k&lt;/td&gt;
&lt;td&gt;时 在一天中 (1~24)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;时 在上午或下午 (0~11)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;td&gt;时区&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;0-9-19版本之后-推荐使用encode&#34;&gt;0.9.19版本之后，推荐使用encode&lt;/h3&gt;

&lt;p&gt;原因： &lt;a href=&#34;https://logback.qos.ch/codes.html#layoutInsteadOfEncoder&#34;&gt;https://logback.qos.ch/codes.html#layoutInsteadOfEncoder&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;size-and-time-based-rolling-policy&#34;&gt;Size and time based rolling policy&lt;/h3&gt;

&lt;p&gt;原地址：&lt;a href=&#34;https://logback.qos.ch/manual/appenders.html#SizeAndTimeBasedFNATP&#34;&gt;https://logback.qos.ch/manual/appenders.html#SizeAndTimeBasedFNATP&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;configuration&amp;gt;
  &amp;lt;appender name=&amp;quot;ROLLING&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
    &amp;lt;file&amp;gt;mylog.txt&amp;lt;/file&amp;gt;
    &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&amp;quot;&amp;gt;
      &amp;lt;!-- rollover daily --&amp;gt;
      &amp;lt;fileNamePattern&amp;gt;mylog-%d{yyyy-MM-dd}.%i.txt&amp;lt;/fileNamePattern&amp;gt;
       &amp;lt;!-- each file should be at most 100MB, keep 60 days worth of history, but at most 20GB --&amp;gt;
       &amp;lt;maxFileSize&amp;gt;100MB&amp;lt;/maxFileSize&amp;gt;    
       &amp;lt;maxHistory&amp;gt;60&amp;lt;/maxHistory&amp;gt;
       &amp;lt;totalSizeCap&amp;gt;20GB&amp;lt;/totalSizeCap&amp;gt;
    &amp;lt;/rollingPolicy&amp;gt;
    &amp;lt;encoder&amp;gt;
      &amp;lt;pattern&amp;gt;%msg%n&amp;lt;/pattern&amp;gt;
    &amp;lt;/encoder&amp;gt;
  &amp;lt;/appender&amp;gt;
  &amp;lt;root level=&amp;quot;DEBUG&amp;quot;&amp;gt;
    &amp;lt;appender-ref ref=&amp;quot;ROLLING&amp;quot; /&amp;gt;
  &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/jingmoxukong/p/5910309.html&#34;&gt;细说Java主流日志工具库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/wangxindong/blog/825066&#34;&gt;门面之下，日志之上-SLF4J&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/?x=0&amp;amp;y=0&amp;amp;s=slf4j&#34;&gt;并发编程网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/huozhonbin/article/category/1656017&#34;&gt;LogBack学习记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://czj4451.iteye.com/blog/1974831&#34;&gt;logback系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://aub.iteye.com/category/161103&#34;&gt;aubdiy - log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java 多态</title>
      <link>http://hugo.xizero.com/java/Java-%E5%A4%9A%E6%80%81/</link>
      <pubDate>Sun, 08 Jan 2017 04:11:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/java/Java-%E5%A4%9A%E6%80%81/</guid>
      <description>

&lt;h1 id=&#34;多态&#34;&gt;多态&lt;/h1&gt;

&lt;p&gt;多态是同一个行为具有多个不同表现形式或形态的能力。&lt;/p&gt;

&lt;p&gt;方法的重写、重载与动态连接构成多态性&lt;/p&gt;

&lt;h2 id=&#34;条件&#34;&gt;条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;继承/实现&lt;/li&gt;
&lt;li&gt;方法的重写和重载&lt;/li&gt;
&lt;li&gt;父类引用指向子类实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;父类引用只能调用父类中定义的变量和方法，以及子类中重写的方法&lt;/p&gt;

&lt;p&gt;动态链接指：父类引用会调用子类实现重写或实现的方法&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java web 序言</title>
      <link>http://hugo.xizero.com/javaee/Java%20web%20%E5%BA%8F%E8%A8%80/</link>
      <pubDate>Fri, 06 Jan 2017 20:56:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/javaee/Java%20web%20%E5%BA%8F%E8%A8%80/</guid>
      <description>

&lt;h1 id=&#34;java-web-序言&#34;&gt;Java web 序言&lt;/h1&gt;

&lt;p&gt;不管怎样，学习越来越迷茫，每一步走地犹犹豫豫，忘记地越来越多，所以写一份总结。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Tomcat</title>
      <link>http://hugo.xizero.com/javaee/Apache%20Tomcat/</link>
      <pubDate>Tue, 03 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/javaee/Apache%20Tomcat/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Http 协议</title>
      <link>http://hugo.xizero.com/javaee/Http%20%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 02 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/javaee/Http%20%E5%8D%8F%E8%AE%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java Servlet</title>
      <link>http://hugo.xizero.com/javaee/Java%20Servlet/</link>
      <pubDate>Sun, 01 Jan 2017 12:00:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/javaee/Java%20Servlet/</guid>
      <description>

&lt;h1 id=&#34;java-servlet&#34;&gt;Java Servlet&lt;/h1&gt;

&lt;h2 id=&#34;什么是-java-servlet&#34;&gt;什么是 Java Servlet ?&lt;/h2&gt;

&lt;p&gt;维基百科：&lt;a href=&#34;https://zh.wikipedia.org/wiki/Java_Servlet&#34;&gt;https://zh.wikipedia.org/wiki/Java_Servlet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javaee/7/tutorial/servlets.htm#BNAFD&#34;&gt;Java Platform, Enterprise Edition: The Java EE Tutorial&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A servlet is a Java programming language class used to extend the capabilities of servers that host applications accessed by means of a request-response programming model.&lt;/p&gt;

&lt;p&gt;Java Servlet 是 Java 应用程序 ，运行在服务器端，由容器进行管理，生成动态内容。&lt;/p&gt;

&lt;p&gt;虽然 servlet 可以响应任何类型的请求，但通常用于web容器，Java Servlet 定义了对 Http 的特定 servlet 类。&lt;/p&gt;

&lt;p&gt;javax.servlet和javax.servlet.http包提供了用于编写servlet的接口和类。 所有servlet必须实现Servlet接口，它&lt;strong&gt;定义了生命周期方法&lt;/strong&gt;。 当实现通用服务时，可以使用或扩展Java Servlet API提供的GenericServlet类。 HttpServlet类提供了用于处理特定于HTTP的服务的方法，例如doGet和doPost。&lt;/p&gt;

&lt;h2 id=&#34;servlet-的生命周期&#34;&gt;Servlet 的生命周期&lt;/h2&gt;

&lt;p&gt;Servlet 的生命周期由 servlet 容器控制。&lt;/p&gt;

&lt;p&gt;当一个请求映射到servlet，容器执行&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果servlet的实例不存在，则web容器：

&lt;ul&gt;
&lt;li&gt;加载servlet类&lt;/li&gt;
&lt;li&gt;创建servlet类的实例&lt;/li&gt;
&lt;li&gt;通过调用初始化servlet实例&lt;strong&gt;init方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;容器调用&lt;strong&gt;service方法&lt;/strong&gt;，判断请求方式，传递请求和响应对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果需要删除该servlet，容器通过调用servlet的&lt;strong&gt;destroy方法&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;servlet-核心类&#34;&gt;Servlet 核心类&lt;/h2&gt;

&lt;p&gt;Java EE API : &lt;a href=&#34;https://docs.oracle.com/javaee/7/api/&#34;&gt;https://docs.oracle.com/javaee/7/api/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;

&lt;p&gt;使用注解 @WebServlet( &amp;ldquo;url &amp;rdquo; ) , url 是 servlet 的路径映射 ，必须是唯一的 ，使用该注解必须继承 HttpServlet&lt;/p&gt;

&lt;p&gt;也可以在 web.xml 中配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;

@WebServlet（“/ test”）
public class ModlServlet extends HttpServlet {
    ... ...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Java 泛型</title>
      <link>http://hugo.xizero.com/java/java-%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Tue, 13 Dec 2016 12:00:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/java/java-%E6%B3%9B%E5%9E%8B/</guid>
      <description>

&lt;h1 id=&#34;泛型&#34;&gt;泛型&lt;/h1&gt;

&lt;h2 id=&#34;泛型是什么&#34;&gt;泛型是什么?&lt;/h2&gt;

&lt;p&gt;泛型是一种编译器机制，在编写代码时&lt;strong&gt;参数化类型&lt;/strong&gt;，在实例化化时&lt;strong&gt;指定&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;泛型编程&#34;&gt;泛型编程&lt;/h2&gt;

&lt;h3 id=&#34;泛型类-容器类&#34;&gt;泛型类/容器类&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;泛型类中依然可以使用基本类型和引用类型，不一定都要参数化类型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义一个泛型类&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在类名后使用 &amp;lt;&amp;gt; 定义一个参数化类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App&amp;lt;T&amp;gt; {
    private T x;

    public T getX() {
        return x;
    }

    public void setX(T x) {
        this.x = x;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例化泛型类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main{
    public static void main(String[] args) {
        
        //指定类型为 String
        App&amp;lt;String&amp;gt; app = new App&amp;lt;&amp;gt;();
        app.setX(&amp;quot;Hello World!&amp;quot;);
        System.out.println(app.getX()); //Hello World!

        //指定类型为 Integer
        App&amp;lt;Integer&amp;gt; app1 = new App&amp;lt;&amp;gt;();
        app1.setX(100);
        System.out.println(app1.getX()); // 100
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;实例化时指定的参数类型必须是类，不能是&lt;strong&gt;基本类型&lt;/strong&gt;，原因看 泛型的实现原理 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义一个有多个参数类型的泛型类&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在 &amp;lt;&amp;gt; 中可以定义多个参数化类型，之间用 , 隔开&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App1&amp;lt;T,U,B&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;App1&amp;lt;String,Integer,String&amp;gt; app1 = new App1&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个泛型抽象类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class App2&amp;lt;T&amp;gt; {
    private T y;

    public T getY() {
        return y;
    }

    public void setY(T y) {
        this.y = y;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继承抽象泛型类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App3 extends App2&amp;lt;String&amp;gt; {
    public static void main(String[] args) {
        App3 app3 = new App3();
        app3.setY(&amp;quot;泛型抽象类&amp;quot;);
        System.out.println(app3.getY());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;参数化类型的名称可以自定义，常用的有KTVE，具体含义看 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;泛型接口&#34;&gt;泛型接口&lt;/h3&gt;

&lt;p&gt;定义一个泛型接口&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;接口中参数化类型的定义和类的一样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IApp&amp;lt;T&amp;gt;{
    public T get();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接口继承泛型接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IApp1 extends IApp&amp;lt;String&amp;gt; {
    public String getAll();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;泛型接口实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public  class AppImpl implements IApp&amp;lt;String&amp;gt; {
    @Override
    public String get() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;泛型方法&#34;&gt;泛型方法&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;泛型方法不只可以泛型类、泛型接口中定义，&lt;strong&gt;普通类&lt;/strong&gt;中也可以&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义一个泛型方法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在普通方法中定义参数化类型，在访问修饰符之后，返回类型之前，使用 &amp;lt;&amp;gt; 定义。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//使用参数化类型定义参数的类型
public &amp;lt;T&amp;gt; void hello(T t){
    System.out.println(&amp;quot;Hello&amp;quot;+t);
}

//使用参数化类型定义返回类型
public &amp;lt;T&amp;gt; T hello2(){
    return null;
}

//一起使用
public &amp;lt;T&amp;gt; T hello3(T t){
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个静态的泛型方法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在静态泛型中定义参数化类型，在static 之后，返回类型之前&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; T world(T t){
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个可变参数的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; void out(T... args) {
    for (T t : args) {
        System.out.println(t);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用泛型方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//像普通的方法一样用
app.hello();
//指定参数化类型
app.&amp;lt;String&amp;gt;hello();
//静态方法也一样
App.world();
App.&amp;lt;String&amp;gt;world();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;泛型的继承&#34;&gt;泛型的继承&lt;/h2&gt;

&lt;h3 id=&#34;泛型类的继承&#34;&gt;泛型类的继承&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;类型参数是当前类定义的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//type parameter of App1
public class App1&amp;lt;T&amp;gt; extends App0&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;泛型类实现泛型接口&#34;&gt;泛型类实现泛型接口&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class App&amp;lt;T&amp;gt; extends IApp&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;泛型接口继承泛型接口&#34;&gt;泛型接口继承泛型接口&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IApp1&amp;lt;T&amp;gt; extends IApp0&amp;lt;T&amp;gt;{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通配符和上下界&#34;&gt;通配符和上下界&lt;/h2&gt;

&lt;h3 id=&#34;通配符&#34;&gt;通配符 ?&lt;/h3&gt;

&lt;p&gt;通配符 ? 表示未知类型，不确定类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;只是用来在实例化时填充&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//定义一个通用的容器类引用
App&amp;lt;?&amp;gt; app;

//指向不同对象
app = new App&amp;lt;String&amp;gt;();

app = new App&amp;lt;Integer&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;上下界&#34;&gt;上下界&lt;/h3&gt;

&lt;p&gt;关键字: extends super&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lt; ? extends T&amp;gt; : 声明上界，表示参数化的类型是 T 或 T 的子类型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;lt; ? super T&amp;gt;：声明下界，表示参数的类型是 T 或 T 的父类型，直至 Object&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解通配符和上下界的三个方面&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引用指向的实现对象是否在上下界范围内&lt;/li&gt;
&lt;li&gt;添加元素时，注意类型是否确定，注意多态（父类引用指向子类实现对象）&lt;/li&gt;
&lt;li&gt;返回值的类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;深入理解 &amp;lt; ? extends T&amp;gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
    static class A{};
    static class B extends A{};
    static class C extends B{};
    
    public static void main(String[] args) {
        List&amp;lt;? extends A&amp;gt; list = new ArrayList&amp;lt;B&amp;gt;();
        //编译器报错
        //list.add(new A());
        //list.add(new B());
        //list.add(new C());
        list.add(null);

        B b = list.get(0);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list 指向的是 A 或者 A 的子类型的ArrayList 对象&lt;/p&gt;

&lt;p&gt;list 不能添加非空元素，原因是 &lt;strong&gt;编译器无法确定List所持有的类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但可以取出时，值得类型是 A ，因为多态，父类引用指向子类实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;深入理解 &amp;lt; ? super T&amp;gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Main {
    static class A{};
    static class B extends A{};
    static class C extends B{};
    public static void main(String[] args) {
        List&amp;lt;? super B&amp;gt; list = new ArrayList&amp;lt;B&amp;gt;();
        //注释掉的编译错误
        //list.add(new A());
        list.add(new B());
        list.add(new Object());
        //list.add(null);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List&amp;lt; ? super B&amp;gt; list 可以指向是 B 或 B 的父类型的 ArrayList 对象&lt;/p&gt;

&lt;p&gt;但是可以添加的元素类型应该是 B 或 B 的子类型，可以添加原因也是多态&lt;/p&gt;

&lt;p&gt;从list中取值，返回的是 Object&lt;/p&gt;

&lt;h2 id=&#34;pecs原则&#34;&gt;PECS原则&lt;/h2&gt;

&lt;p&gt;如果要从集合中读取类型T的数据，并且&lt;strong&gt;不能写入&lt;/strong&gt;，可以使用 ? extends 通配符；(Producer Extends)&lt;/p&gt;

&lt;p&gt;如果要从集合中写入类型T的数据，并且&lt;strong&gt;不需要读取&lt;/strong&gt;，可以使用 ? super 通配符；(Consumer Super)&lt;/p&gt;

&lt;p&gt;如果既要存又要取，那么就不要使用任何通配符。&lt;/p&gt;

&lt;p&gt;出 处 ：&lt;a href=&#34;http://flyingcat2013.blog.51cto.com/7061638/1616068&#34;&gt;Java泛型中的PECS原则&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;和-t-的区别&#34;&gt;? 和 T 的区别&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;? 用在&lt;strong&gt;实例&lt;/strong&gt;泛型时，填充范围。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;T 用在&lt;strong&gt;定义&lt;/strong&gt;泛型时，参数化类型。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;与上下界一起使用时，区别还是一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;泛型的实现原理&#34;&gt;泛型的实现原理&lt;/h2&gt;

&lt;p&gt;泛型的实现在编译阶段，通过&lt;strong&gt;类型擦除&lt;/strong&gt;实现&lt;/p&gt;

&lt;h3 id=&#34;type-erasure-http-docs-oracle-com-javase-tutorial-java-generics-erasure-html&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/java/generics/erasure.html&#34;&gt;Type Erasure&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming.&lt;/p&gt;

&lt;p&gt;Java 引入泛型，可以在编译时提供更严格的类型检查，并且支持泛型编程。&lt;/p&gt;

&lt;p&gt;To implement generics, the Java compiler applies type erasure to:&lt;/p&gt;

&lt;p&gt;为了实现泛型，java 编译器使用类型擦除 ：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.&lt;/li&gt;
&lt;li&gt;Insert type casts if necessary to preserve type safety.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate bridge methods to preserve polymorphism in extended generic types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将所有参数类型替换成其边界，如果没有边界替换成 Object 。因此，产生的字节码文件仅仅包含普通类、接口和方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;必要时添加类型转换以保存类型安全&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成桥方法以在扩展泛型时保持多态性&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.&lt;/p&gt;

&lt;p&gt;类型擦除确保不因为参数化类型而创建新类； 因此，泛型不会产生运行时开销。&lt;/p&gt;

&lt;h3 id=&#34;几种擦除&#34;&gt;几种擦除&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;T&gt;  &amp;ndash;&amp;gt; Object&lt;/li&gt;
&lt;li&gt;&amp;lt;? extends T&amp;gt; &amp;ndash;&amp;gt; T&lt;/li&gt;
&lt;li&gt;&amp;lt;? super T&amp;gt; &amp;ndash;&amp;gt; Object&lt;/li&gt;
&lt;li&gt;添加桥接方法，保证多态性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与之前的深入理解有关&lt;/p&gt;

&lt;h3 id=&#34;类型擦除的相关&#34;&gt;类型擦除的相关&lt;/h3&gt;

&lt;p&gt;1.类型擦除，在编译之前进行类型检查&lt;/p&gt;

&lt;p&gt;2.泛型与重载&lt;/p&gt;

&lt;p&gt;因为类型擦除，所以下面的两个方法的参数类型相同，会报错，both methods hava same erasure.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void a(List&amp;lt;Object&amp;gt; list){};
public void a(List&amp;lt;String&amp;gt; list){};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.泛型与多态&lt;/p&gt;

&lt;p&gt;会生成桥方法，以保证多态&lt;/p&gt;

&lt;p&gt;4.泛型与static&lt;/p&gt;

&lt;p&gt;类的参数化类型不能定义静态变量和方法。&lt;/p&gt;

&lt;p&gt;但是泛型方法可以定义成静态方法，它使用的自己的参数类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; T get( STring s){};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;泛型类的所有静态变量是共享的。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/sharewind/archive/2012/11/26/2788698.html&#34;&gt;Java泛型通配符extends与super&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/255&#34;&gt;Java泛型中extends和super的理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/226&#34;&gt;Java的类型擦除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/lonelyroamer/article/details/7868820&#34;&gt;java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>java 泛型 TKVE 含义</title>
      <link>http://hugo.xizero.com/java/java-%E6%B3%9B%E5%9E%8B-TKVE/</link>
      <pubDate>Thu, 24 Nov 2016 15:55:43 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/java/java-%E6%B3%9B%E5%9E%8B-TKVE/</guid>
      <description>

&lt;h2 id=&#34;java-泛型经常使用的符号的含义&#34;&gt;Java 泛型经常使用的符号的含义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;T &amp;ndash; Type / java 类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;K &amp;ndash; Key / 键&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;V &amp;ndash; Value / 值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;E &amp;ndash; Element / 集合中的元素&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;? &amp;ndash; 通配符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;S、U、V &amp;ndash; 2nd、3rd、4th types&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;www.hollischuang.com/archives/252&#34;&gt;Java泛型中K T V E ？ object等的含义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java 序列化</title>
      <link>http://hugo.xizero.com/java/java-%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 23 Nov 2016 16:28:21 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/java/java-%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>

&lt;h2 id=&#34;什么是序列化&#34;&gt;什么是序列化？&lt;/h2&gt;

&lt;p&gt;序列化是为了保存对象的状态，将对象的状态装换为字节数组，反序列化就是重构对象。&lt;/p&gt;

&lt;p&gt;就像是冰冻魔法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相关API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;java.io.Serializable&lt;/li&gt;
&lt;li&gt;java.io.Externalizable&lt;/li&gt;
&lt;li&gt;ObjectOutput&lt;/li&gt;
&lt;li&gt;ObjectInput&lt;/li&gt;
&lt;li&gt;ObjectOutputStream&lt;/li&gt;
&lt;li&gt;ObjectInputStream&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;怎么用&#34;&gt;怎么用？&lt;/h2&gt;

&lt;p&gt;只要一个类实现了 &lt;code&gt;java.io.Serializable&lt;/code&gt; 接口就能被序列化,该接口仅作为一个标识，标识这个类可以进行序列化。&lt;/p&gt;

&lt;p&gt;ObjectOutputStream.writeObject(Object); 将对象入输出流，序列化&lt;/p&gt;

&lt;p&gt;ObjectInputStream.readObject(); 从流中读取对象，反序列化&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;标识:在进行序列化时，在 writeObject() 中会检测 obj instanceof Serializable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;例&#34;&gt;例&lt;/h3&gt;

&lt;p&gt;序列化对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.Serializable;

public class Cat implements Serializable {
    private String name;
    private String age;
    private static final long serialVersionUID = 1L;
    public Cat() {
    }

    public Cat(String name, String age) {

        this.name = name;
        this.age = age;
    }

   //get() set()

    @Override
    public String toString() {
        return &amp;quot;Cat{&amp;quot; +
                &amp;quot;name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, age=&#39;&amp;quot; + age + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;序列化过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.x.model.Cat;

import java.io.*;

public class Main {

    public static void main(String[] args) {
        Cat cat = new Cat(&amp;quot;huang&amp;quot;,&amp;quot;5&amp;quot;);
        System.out.println(cat);



        try (FileOutputStream file = new FileOutputStream(&amp;quot;he&amp;quot;); ObjectOutputStream oos =  new ObjectOutputStream(file);){
            oos.writeObject(cat);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (FileInputStream file = new FileInputStream(&amp;quot;he&amp;quot;);ObjectInputStream ois = new ObjectInputStream(file)) {
            Cat cat1 = (Cat)ois.readObject();
            System.out.println(cat1);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用 Externalizable 接口，需要重写 writeExternal() 和 readExternal() ，可自定义序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化ID(private static final long serialVersionUID)不同，反序列化报java.io.InvalidClassException异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;静态变量不会序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 transient 关键字的变量不会序列化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化中继承&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;父类实现序列化，子类默认继承&lt;/li&gt;
&lt;li&gt;子类实现序列化，若父类变量也要保存则需要父类序列化；不需要父类序列化，反序列化时调用父类的无参构造函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/1150&#34;&gt;Java对象的序列化与反序列化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-5things1/&#34;&gt;关于 Java 对象序列化您不知道的 5 件事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-serial/&#34;&gt;Java 序列化的高级认识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>String 相关</title>
      <link>http://hugo.xizero.com/java/String%20%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Tue, 22 Nov 2016 08:36:39 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/java/String%20%E7%9B%B8%E5%85%B3/</guid>
      <description>

&lt;h2 id=&#34;string-成员变量&#34;&gt;String 成员变量&lt;/h2&gt;

&lt;p&gt;String 是典型的&lt;a href=&#34;http://www.cnblogs.com/java-my-life/archive/2012/05/08/2487757.html&#34;&gt;不变模式设计&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/String.java?av=f&#34;&gt;JDK 8 源码地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/String.java?av=f&#34;&gt;JDK 6 源码地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
//JDK 1.8
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {
    //The value is used for character storage.
    private final char value[];

    //Cache the hash code for the string
    private int hash; // Default to 0
}

//JDK1.6
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence{
    //The value is used for character storage.
    private final char value[];

    //The offset is the first index of the storage that is used.
    private final int offset;

    //The count is the number of characters in the String.
    private final int count;

    //Cache the hash code for the string
    private int hash; // Default to 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常量池&#34;&gt;常量池&lt;/h2&gt;

&lt;p&gt;java编译时会生成常量池（Constant pool），保存字面常量和符号引用（类名、方法名、接口名和字段名等）。&lt;/p&gt;

&lt;h3 id=&#34;创建字符串对象&#34;&gt;创建字符串对象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;new 运算符&lt;/li&gt;
&lt;li&gt;字符串常量&lt;/li&gt;
&lt;li&gt;&amp;rdquo;+&amp;ldquo;连接的表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相同的字符串常量或结果相同的字符串常量表达式创建字符串对象时，
如果常量池中已经存在，相同序列的字符串，则该对象直接指向；不存在时，会在常量池创建一个新的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String a1 = &amp;quot;abc&amp;quot;;
String a2 = &amp;quot;abc&amp;quot;;
String a3 = &amp;quot;a&amp;quot;+&amp;quot;bc&amp;quot;;
System,out.println(a1==a2+&amp;quot;\t&amp;quot;+a2==a3); //true true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为字符串序列相同，指向的常量池中同一个字符串，所以为true。&lt;/p&gt;

&lt;p&gt;使用 new 创建字符串对象时，会在堆中创建一个新的String对象，并且该String对象的char value[]会指向常量池中的字符串，不存在则创建。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
String b1 = new String(&amp;quot;abc&amp;quot;);
String b2 = new String(&amp;quot;abc&amp;quot;);
System.out.println(b1==b2); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用new会在堆中创建新的对象,地址当然不同.&lt;/p&gt;

&lt;h3 id=&#34;string&#34;&gt;String +&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&amp;rdquo; &amp;ldquo;+[String] 或 [String]+[String]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;会在编译时,调用StringBuilder的append()和toString(),最终指向的是堆上新创建的String对象.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String c1 = &amp;quot;abc&amp;quot;;
String c2 = &amp;quot;123&amp;quot;+c1;
String c3 = &amp;quot;123abc&amp;quot;;
System.out.println(c2==c3); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;rdquo; &amp;ldquo;+&amp;rdquo; &amp;ldquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[final String]+[final String] 或 [final String]+&amp;rdquo; &amp;ldquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当final修饰的对象发生连接动作时，虚拟机会进行优化，将表达式结果直接赋值给目标变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final String a = &amp;quot;hello &amp;quot;;
final String b = &amp;quot;world&amp;quot;;
String c = a + &amp;quot;world&amp;quot;;
String d = &amp;quot;hello world&amp;quot;;
System.out.println(c==d); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string-intern&#34;&gt;String.intern()&lt;/h2&gt;

&lt;p&gt;是一个 Native 方法，调用 C++的 StringTable::intern&lt;/p&gt;

&lt;p&gt;如果常量池中已经存在该字符串，则返回池中的字符串；否则将此字符串添加到常量池中，并返回引用。&lt;/p&gt;

&lt;h2 id=&#34;string-substring&#34;&gt;String.substring()&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//JDK1.6
public String substring(int beginIndex) {
    return substring(beginIndex, count);
}
public String substring(int beginIndex, int endIndex) {
    if (beginIndex &amp;lt; 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex &amp;gt; count) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (beginIndex &amp;gt; endIndex) {
        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);
    }
    return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == count)) ? this :
        new String(offset + beginIndex, endIndex - beginIndex, value);
}

String(int offset, int count, char value[]) {
    this.value = value;
    this.offset = offset;
    this.count = count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JDK1.6 中的实现只是调整了 offset 和 count ,使用的是共享的字符数组。&lt;/p&gt;

&lt;p&gt;当使用substring截取一个很长的字符串的2个字符时，会占用这个长字符串，不能垃圾回收。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//JDK 1.8
public String substring(int beginIndex) {
        if (beginIndex &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        int subLen = value.length - beginIndex;
        if (subLen &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}

public String substring(int beginIndex, int endIndex) {
        if (beginIndex &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        if (endIndex &amp;gt; value.length) {
            throw new StringIndexOutOfBoundsException(endIndex);
        }
        int subLen = endIndex - beginIndex;
        if (subLen &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);
}

public String(char value[], int offset, int count) {
        if (offset &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(offset);
        }
        if (count &amp;lt; 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        // Note: offset or count might be near -1&amp;gt;&amp;gt;&amp;gt;1.
        if (offset &amp;gt; value.length - count) {
            throw new StringIndexOutOfBoundsException(offset + count);
        }
        this.value = Arrays.copyOfRange(value, offset, offset+count);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析一下 substring 源码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;报StringIndexOutOfBoundsException异常

&lt;ul&gt;
&lt;li&gt;beginIndex &amp;lt; 0&lt;/li&gt;
&lt;li&gt;endIndex &amp;gt; value.length&lt;/li&gt;
&lt;li&gt;subLen &amp;lt; 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;subLen 是新的字符串的长度&lt;/li&gt;
&lt;li&gt;endIndex的意义不明确

&lt;ul&gt;
&lt;li&gt;理解为 beginIndex + subLen&lt;/li&gt;
&lt;li&gt;beginIndex &amp;lt;= endIndex &amp;lt;= value.length&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当截取范围与原字符串相同返回this，否则 new 一个新的String对象,在构造方法中复制生成了新的 value。&lt;/li&gt;
&lt;li&gt;substring(1,1)

&lt;ul&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;==s.substring(1,1) //true&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;.equals(s.substring(1,1)) //false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过反射机制可以对String进行修改&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;== 和 equals()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;== 比较引用是否指向堆内存中的同一个String对象&lt;/li&gt;
&lt;li&gt;equals() 比较的是字符串的内容是否相同&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String StringBuilder StringBuffer 区别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;String是不可变(final)类，每次在String对象上的操作都会生成一个新的对象；&lt;/li&gt;
&lt;li&gt;StringBuffer和StringBuilder是可变的，它允许在原来对象上进行操作，而不用每次增加对象；&lt;/li&gt;
&lt;li&gt;StringBuffer是线程安全的，但效率较低，而StringBuilder则不是线程安全的，效率最高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考连接&#34;&gt;参考连接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/21711.html&#34;&gt;浅谈Java String内幕（上）&lt;/a&gt; &amp;ndash; javap 查看字节码&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/99&#34;&gt;Java 7 源码学习系列（一）——String&lt;/a&gt; &amp;ndash; 看源码解释&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://brokendreams.iteye.com/blog/2260870&#34;&gt;关于Java String的一些总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java IO</title>
      <link>http://hugo.xizero.com/java/java-io/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/java/java-io/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;关于 Java IO 还没有一个整体的结构，所以先写一点常用的东西&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;h3 id=&#34;io常执行的操作&#34;&gt;IO常执行的操作：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;文件的创建、删除、移动、复制&lt;/li&gt;
&lt;li&gt;对文件或网络套字节中读取和写入&lt;/li&gt;
&lt;li&gt;把对象序列化到持久储存中，并获取保存的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一点历史&#34;&gt;一点历史：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JDK 1.0 ，Java 以 java.io 包中的 I/O API 的形式提供支持 I/O&lt;/li&gt;
&lt;li&gt;JDK 1.4 ，添加了 java.nio&lt;/li&gt;
&lt;li&gt;JDK 1.7 ，引入 NIO.2 的包来补充&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;注意&#34;&gt;注意：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;新的版本中，Path 接口是 java.io.File 类的升级&lt;/li&gt;
&lt;li&gt;JDK 1.7 中添加了 java.lang.AutoCloseable 接口，实现了 try-with-resources&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;文件系统-路径和一些工具类&#34;&gt;文件系统、路径和一些工具类&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html&#34;&gt;Interface Path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html&#34;&gt;Class FileSystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html&#34;&gt;Class Paths&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystems.html&#34;&gt;Class FileSystems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;创建一个路径&#34;&gt;创建一个路径&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Paths 的静态方法 get()&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Modifier and Type&lt;/th&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;static Path&lt;/td&gt;
&lt;td&gt;get(String first, String&amp;hellip; more)&lt;/td&gt;
&lt;td&gt;Converts a path string, or a sequence of strings that when joined form a path string, to a Path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;static Path&lt;/td&gt;
&lt;td&gt;get(URI uri)&lt;/td&gt;
&lt;td&gt;Converts the given URI to a Path object.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Path p = Paths.get(&amp;quot;C:/temp&amp;quot;);
Path p_ = Paths.get(&amp;quot;/home&amp;quot;,&amp;quot;user&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;FileSystem 的成员方法 getPath()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;可以通过 FileSystems 的静态方法 getDefault()获取默认的FileSystem&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Modifier and Type&lt;/th&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abstract Path&lt;/td&gt;
&lt;td&gt;getPath(String first, String&amp;hellip; more)&lt;/td&gt;
&lt;td&gt;Converts a path string, or a sequence of strings that when joined form a path string, to a Path.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Path p =FileSystes.getDefault().getPath(&amp;quot;/home&amp;quot;,&amp;quot;user&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;interface-path&#34;&gt;Interface Path&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html&#34;&gt;JDK API : Interface Path&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Modifier and Type&lt;/th&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;normalize()&lt;/td&gt;
&lt;td&gt;路径普通化 Returns a path that is this path with redundant name elements eliminated.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;subpath(int beginIndex, int endIndex)&lt;/td&gt;
&lt;td&gt;截取子路径 Returns a relative Path that is a subsequence of the name elements of this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;判断路径开头和结尾&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;startsWith(Path other)&lt;/td&gt;
&lt;td&gt;Tests if this path starts with the given path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;startsWith(String other)&lt;/td&gt;
&lt;td&gt;Tests if this path starts with a Path, constructed by converting the given path string, in exactly the manner specified by the startsWith(Path) method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;endsWith(Path other)&lt;/td&gt;
&lt;td&gt;Tests if this path ends with the given path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;endsWith(String other)&lt;/td&gt;
&lt;td&gt;Tests if this path ends with a Path, constructed by converting the given path string, in exactly the manner specified by the endsWith(Path) method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;获取路径的相关信息&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;getFileName()&lt;/td&gt;
&lt;td&gt;Returns the name of the file or directory denoted by this path as a Path object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FileSystem&lt;/td&gt;
&lt;td&gt;getFileSystem()&lt;/td&gt;
&lt;td&gt;Returns the file system that created this object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;getName(int index)&lt;/td&gt;
&lt;td&gt;Returns a name element of this path as a Path object.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;getNameCount()&lt;/td&gt;
&lt;td&gt;Returns the number of name elements in the path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;getParent()&lt;/td&gt;
&lt;td&gt;Returns the parent path, or null if this path does not have a parent.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;getRoot()&lt;/td&gt;
&lt;td&gt;Returns the root component of this path as a Path object, or null if this path does not have a root component.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Path to Path&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;relativize(Path other)&lt;/td&gt;
&lt;td&gt;Constructs a relative path between this path and a given path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;路径替换拼接&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;resolve(Path other)&lt;/td&gt;
&lt;td&gt;Resolve the given path against this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;resolve(String other)&lt;/td&gt;
&lt;td&gt;Converts a given path string to a Path and resolves it against this Path in exactly the manner specified by the resolve method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;resolveSibling(Path other)&lt;/td&gt;
&lt;td&gt;Resolves the given path against this path&amp;rsquo;s parent path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;resolveSibling(String other)&lt;/td&gt;
&lt;td&gt;Converts a given path string to a Path and resolves it against this path&amp;rsquo;s parent path in exactly the manner specified by the resolveSibling method.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;转换&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;isAbsolute()&lt;/td&gt;
&lt;td&gt;Tells whether or not this path is absolute.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;toAbsolutePath()&lt;/td&gt;
&lt;td&gt;Returns a Path object representing the absolute path of this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;File&lt;/td&gt;
&lt;td&gt;toFile()&lt;/td&gt;
&lt;td&gt;Returns a File object representing this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;toRealPath(LinkOption&amp;hellip; options)&lt;/td&gt;
&lt;td&gt;Returns the real path of an existing file.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;URI&lt;/td&gt;
&lt;td&gt;toUri()&lt;/td&gt;
&lt;td&gt;Returns a URI to represent this path.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;toString()&lt;/td&gt;
&lt;td&gt;Returns the string representation of this path.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;*deleteIfExists(Path)  删除不存在path时，不会报 NoSuchFileException 异常 *&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java 修饰符</title>
      <link>http://hugo.xizero.com/java/java-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/java/java-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>

&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;访问修饰符 &lt;code&gt;public&lt;/code&gt;、&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;、default&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非访问修饰符 &lt;code&gt;static&lt;/code&gt;、&lt;code&gt;final&lt;/code&gt;、&lt;code&gt;abstract&lt;/code&gt;、&lt;code&gt;synchronized&lt;/code&gt;、&lt;code&gt;transient&lt;/code&gt;、&lt;code&gt;volatile&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;访问修饰符&#34;&gt;访问修饰符&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;保护对类、变量、方法和构造方法的访问&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;公有访问修饰符-public&#34;&gt;公有访问修饰符 &amp;ndash; public&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不同的包中，则需要导入相应 public 类所在的包。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于类的继承性，类所有的公有方法和变量都能被其子类继承&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;私有访问修饰符-private&#34;&gt;私有访问修饰符 &amp;ndash; private&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;被声明为 private 的方法、变量和构造方法只能被所属类访问&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类和接口不能声明为 private&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;声明为私有访问类型的变量只能通过类中公共的 Getter\/Setter 方法被外部类访问&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;保护访问修饰符-protected&#34;&gt;保护访问修饰符 &amp;ndash; protected&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;子类能访问 Protected 修饰符声明的方法和变量&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;默认访问修饰符&#34;&gt;默认访问修饰符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口里的变量都隐式声明为 public static final, 而接口里的方法默认情况下访问权限为 public&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;权限比较&#34;&gt;权限比较&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;访问修饰符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;所属类&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;所属包的其他类&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;子类&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;其他包的其他类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;public&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;protected&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;default&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;private&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;访问控制与继承&#34;&gt;访问控制与继承&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;继承中，子类的权限不能小于父类的。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;父类中声明为 public 的方法在子类中也必须为 public。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;父类中默认修饰符声明的方法，能够在子类中声明为 protected。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;父类中声明为 private 的方法，不能够被继承。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;非访问修饰符&#34;&gt;非访问修饰符&lt;/h2&gt;

&lt;h3 id=&#34;static-修饰符&#34;&gt;static 修饰符&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;被 static 修饰的成员变量和成员方法独立于该类的任何对象，被所有对象共享。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;静态变量&#34;&gt;静态变量&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;用static修饰的成员变量称为静态变量，其他的称为实例变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;静态变量在加载类的过程中完成空间分配，只有一份拷贝，可以直接用类名访问。&lt;/p&gt;

&lt;p&gt;实例变量在对象实例化时分配内存。&lt;/p&gt;

&lt;h4 id=&#34;静态方法&#34;&gt;静态方法&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;静态方法中不能用 this 和 super 关键字，不能直接访问所属类的实例变量和实例方法，只能访问所属类的静态成员变量和成员方法&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;静态代码块&#34;&gt;静态代码块&lt;/h4&gt;

&lt;p&gt;请看代码块相关内容。&lt;/p&gt;

&lt;h4 id=&#34;静态导入&#34;&gt;静态导入&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 导入某个特定的静态方法
import static packageName.className.methonName;

// 导入类中的所有静态成员
import static packageName.className.*;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在当前类中直接用方法名调用静态方法，不必再通过类名来访问。&lt;/p&gt;

&lt;h3 id=&#34;final-修饰符&#34;&gt;final 修饰符&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;最终的，不可改变&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;final-变量&#34;&gt;final 变量&lt;/h4&gt;

&lt;p&gt;final 变量即常量，仅可以赋值一次。&lt;/p&gt;

&lt;p&gt;final 修饰的成员变量，要显示初始化，如果没有只能在构造函数中进行一次赋值&lt;/p&gt;

&lt;p&gt;当变量为引用类型的时候，不可以改变引用对象，但可以改变对象的属性等。&lt;/p&gt;

&lt;h4 id=&#34;final-方法&#34;&gt;final 方法&lt;/h4&gt;

&lt;p&gt;final 可以被子类继承，但不可以覆盖。&lt;/p&gt;

&lt;h4 id=&#34;final-类&#34;&gt;final 类&lt;/h4&gt;

&lt;p&gt;final 类不可继承。&lt;/p&gt;

&lt;h4 id=&#34;final-static&#34;&gt;final static&lt;/h4&gt;

&lt;p&gt;成员变量，必须显示初始化，不可以修改，成员方法不可覆盖，可以通过类名直接访问。&lt;/p&gt;

&lt;h3 id=&#34;abstract-修饰符&#34;&gt;Abstract 修饰符&lt;/h3&gt;

&lt;p&gt;用来定义抽象方法和抽象类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;abstract 不可以 与 final , private , static 共存&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Abstract 修饰后，必须通过类继承或者接口实现来重写，否则就是摆设。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;final 修饰的类 \ 方法 \ 属性均不可再次更改，故而不可以被重写。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;private 修饰的类只可以定义在内部类；private 修饰的方法 \ 属性只可以在类中调用，重写时是访问不到这些方法和属性的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;static 静态的，其修饰的方法 \ 属性，是随着类的创建而创建，类的消亡而消亡，在编译时就已经确定的东西；但是 abstract 是 dynamic（动态）的，其必须通过类继承或接口实现来动态重写 abstract 方法。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;synchronized-修饰符&#34;&gt;Synchronized 修饰符&lt;/h3&gt;

&lt;p&gt;Synchronized 关键字声明的方法同一时间只能被一个线程访问&lt;/p&gt;

&lt;h3 id=&#34;transient-修饰符&#34;&gt;Transient 修饰符&lt;/h3&gt;

&lt;p&gt;序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机 (JVM) 跳过该特定的变量。&lt;/p&gt;

&lt;p&gt;该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。&lt;/p&gt;

&lt;h3 id=&#34;volatile-修饰符&#34;&gt;Volatile 修饰符&lt;/h3&gt;

&lt;p&gt;Volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。&lt;/p&gt;

&lt;p&gt;一个 volatile 对象引用可能是 null。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java 反射</title>
      <link>http://hugo.xizero.com/java/java-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Fri, 18 Nov 2016 18:20:00 +0800</pubDate>
      
      <guid>http://hugo.xizero.com/java/java-%E5%8F%8D%E5%B0%84/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;反射是将java 类中的各种成分映射成相应的类。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&lt;/p&gt;

&lt;h2 id=&#34;class-name&#34;&gt;Class Name&lt;/h2&gt;

&lt;h3 id=&#34;获取完整类名&#34;&gt;获取完整类名&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String className = class.getName();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;获取不包含包名的类名&#34;&gt;获取不包含包名的类名&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String simpleClassName = class.getWSimpleName();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;class-modifies&#34;&gt;Class Modifies&lt;/h2&gt;

&lt;h3 id=&#34;获取修饰class-对象的访问修饰符&#34;&gt;获取修饰Class 对象的访问修饰符&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int modifiers = class.getModifiers();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;检查修饰符&#34;&gt;检查修饰符&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import  java.lang.reflect.Modifier;

Modifier.isAbstract(int modifiers)
Modifier.isFinal(int modifiers)
Modifier.isInterface(int modifiers)
Modifier.isNative(int modifiers)
Modifier.isPrivate(int modifiers)
Modifier.isProtected(int modifiers)
Modifier.isPublic(int modifiers)
Modifier.isStatic(int modifiers)
Modifier.isStrict(int modifiers)
Modifier.isSynchronized(int modifiers)
Modifier.isTransient(int modifiers)
Modifier.isVolatile(int modifiers)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;package-info&#34;&gt;Package Info&lt;/h2&gt;

&lt;p&gt;获取包的相关信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Package package = class.getPackage();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;superclass&#34;&gt;Superclass&lt;/h2&gt;

&lt;p&gt;获取超类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class superclass = class.getSuperclass();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implemented-interfaces&#34;&gt;Implemented Interfaces&lt;/h2&gt;

&lt;p&gt;获得类实现的接口的列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class[] interfaces = class.getInterfaces();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要获取一个给定类的完整的所实现接口的列表，需要递归查询该类以及它的超类。&lt;/p&gt;

&lt;h2 id=&#34;constructors&#34;&gt;Constructors&lt;/h2&gt;

&lt;h3 id=&#34;获得构造函数&#34;&gt;获得构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Constructor[] constructors = class.getConstructors();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;获取指定参数的构造函数&#34;&gt;获取指定参数的构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Constructor constructor = class.getConstructor(new Class[]{String.class});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;获取构造函数的参数&#34;&gt;获取构造函数的参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class[] parameterTypes = constructor.getParameterTypes();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;调用构造函数-实例化对象&#34;&gt;调用构造函数，实例化对象&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Constructor constructor = MyObject.class.getConstructor(String.class);
MyObject myObject = (MyObject) constructor.newInstance(&amp;quot;参数&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;methods&#34;&gt;Methods&lt;/h2&gt;

&lt;h3 id=&#34;获取类中的公共方法&#34;&gt;获取类中的公共方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Method[] method = class.getMethods();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;获取指定的方法&#34;&gt;获取指定的方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//不存在与参数匹配的方法时，报 NoSuchMethodException 异常
Method method = class.getMethod(&amp;quot;doSomething&amp;quot;, new Class[]{String.class});
Method method = aClass.getMethod(&amp;quot;doSomething&amp;quot;, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;获取方法的参数&#34;&gt;获取方法的参数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class[] parameterTypes = method.getParameterTypes();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;获取方法的返回值类型&#34;&gt;获取方法的返回值类型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class returnType = method.getReturnType();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;调用方法&#34;&gt;调用方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Method.invoke(Object target, Object... parameters)
//参数  target  是要调用方法的对象
//静态方法需要提供null作为参数，非静态方法需要提供对象的实例。

Method method = MyObject.class.getMethod(&amp;quot;doSomething&amp;quot;, String.class);
Object returnValue = method.invoke(null, &amp;quot;parameter-value1&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fields&#34;&gt;Fields&lt;/h2&gt;

&lt;h3 id=&#34;获取类的公共字段&#34;&gt;获取类的公共字段&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Field[] fields = class.getFields();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;获取指定字段名的字段&#34;&gt;获取指定字段名的字段&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Field field = class.getField(&amp;quot;字段名&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;根据字段获取字段名&#34;&gt;根据字段获取字段名&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String fieldName = field.getName();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;根据字段获取字段类型&#34;&gt;根据字段获取字段类型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class fieldType = field.getType();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过字段获取设置字段的值&#34;&gt;通过字段获取设置字段的值&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//参数objectInstance必须是拥有该字段的实例
Class  class_  = MyObject.class
Field field = class_.getField(&amp;quot;字段名&amp;quot;);
MyObject objectInstance = new MyObject();
Object value = field.get(objectInstance);
field.set(objetInstance, value);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;annotations&#34;&gt;Annotations&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Annotation[] annotations = class.getAnnotations();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于私有成员&#34;&gt;关于私有成员&lt;/h2&gt;

&lt;h3 id=&#34;私有字段&#34;&gt;私有字段&lt;/h3&gt;

&lt;p&gt;获得私有字段，仅仅在当前类中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Field field = class.getDeclaredField(String name);

Field[] fields = class.getDeclaredFields();

field.setAccessible(true); //关闭对特定的Field实例的访问检查
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;私有方法&#34;&gt;私有方法&lt;/h3&gt;

&lt;p&gt;获得私有方法，仅仅在当前类中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Method  method = class.getDeclaredMethod(String name, Class[ ] parameterTypes);

Method[] method = class.getDeclaredMethods();

method.setAccessible(true); //关闭对特定的Method实例的访问检查
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;

&lt;h3 id=&#34;创建数组&#34;&gt;创建数组&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.reflect.Array;

int[] intArray = (int[]) Array.newInstance(int.class, 3);
//第一个参数int.class指定了数组类型。
//第二个参数声明了数组大小。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get-和-set&#34;&gt;get 和 set&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Array.get(数组实例,序列);

Array.set(数组实例,序列,值);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;获取数组的类型&#34;&gt;获取数组的类型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Class class_ = class.getComponentType();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/penghongwei/p/3299688.html&#34;&gt;Java 反射 【译】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-reflection/index.html&#34;&gt;java-reflection [英] &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>