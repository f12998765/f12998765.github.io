<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.18.1" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="//fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="/css/main.css">
<link rel="alternate" href="/index.xml" type="application/rss+xml" title="XIZERO">
<link href="https://cdn.bootcss.com/highlight.js/9.7.0/styles/tomorrow.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/9.8.0/highlight.min.js"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
<script src="http://127.0.0.1/js/top.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<title>Java 修饰符 - XIZERO</title>
</head>
<body>

<div id="gotop" title="🚀 go top"></div>

<div class="top">

	<div class="gos">
		<span class="go"><a href="/">Home</a></span>
		<span class="go"><a href="/tags">Tags</a></span>
		<span class="go"><a href="/about">About</a></span>
	</div>
	
	
		<div class="tit">
			Java 修饰符
		</div>

	

</div>




<div class="con">
	

<h2 id="分类">分类</h2>

<ul>
<li><p>访问修饰符 <code>public</code>、<code>private</code>、<code>protected</code>、default</p></li>

<li><p>非访问修饰符 <code>static</code>、<code>final</code>、<code>abstract</code>、<code>synchronized</code>、<code>transient</code>、<code>volatile</code></p></li>
</ul>

<h2 id="访问修饰符">访问修饰符</h2>

<p><strong>保护对类、变量、方法和构造方法的访问</strong></p>

<h3 id="公有访问修饰符-public">公有访问修饰符 &ndash; public</h3>

<ul>
<li><p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问</p></li>

<li><p>不同的包中，则需要导入相应 public 类所在的包。</p></li>

<li><p>由于类的继承性，类所有的公有方法和变量都能被其子类继承</p></li>
</ul>

<h3 id="私有访问修饰符-private">私有访问修饰符 &ndash; private</h3>

<ul>
<li><p>被声明为 private 的方法、变量和构造方法只能被所属类访问</p></li>

<li><p>类和接口不能声明为 private</p></li>

<li><p>声明为私有访问类型的变量只能通过类中公共的 Getter\/Setter 方法被外部类访问</p></li>
</ul>

<h3 id="保护访问修饰符-protected">保护访问修饰符 &ndash; protected</h3>

<ul>
<li><p>被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。</p></li>

<li><p>Protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected</p></li>

<li><p>子类能访问 Protected 修饰符声明的方法和变量</p></li>
</ul>

<h3 id="默认访问修饰符">默认访问修饰符</h3>

<ul>
<li><p>使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的</p></li>

<li><p>接口里的变量都隐式声明为 public static final, 而接口里的方法默认情况下访问权限为 public</p></li>
</ul>

<h3 id="权限比较">权限比较</h3>

<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>所属类</th>
<th>所属包的其他类</th>
<th>子类</th>
<th>其他包的其他类</th>
</tr>
</thead>

<tbody>
<tr>
<td>public</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>

<tr>
<td>protected</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>

<tr>
<td>default</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>

<tr>
<td>private</td>
<td>O</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>

<h3 id="访问控制与继承">访问控制与继承</h3>

<p><strong>继承中，子类的权限不能小于父类的。</strong></p>

<ul>
<li><p>父类中声明为 public 的方法在子类中也必须为 public。</p></li>

<li><p>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。</p></li>

<li><p>父类中默认修饰符声明的方法，能够在子类中声明为 protected。</p></li>

<li><p>父类中声明为 private 的方法，不能够被继承。</p></li>
</ul>

<h2 id="非访问修饰符">非访问修饰符</h2>

<h3 id="static-修饰符">static 修饰符</h3>

<p><strong>被 static 修饰的成员变量和成员方法独立于该类的任何对象，被所有对象共享。</strong></p>

<h4 id="静态变量">静态变量</h4>

<p><strong>用static修饰的成员变量称为静态变量，其他的称为实例变量</strong></p>

<p>静态变量在加载类的过程中完成空间分配，只有一份拷贝，可以直接用类名访问。</p>

<p>实例变量在对象实例化时分配内存。</p>

<h4 id="静态方法">静态方法</h4>

<p><strong>静态方法中不能用 this 和 super 关键字，不能直接访问所属类的实例变量和实例方法，只能访问所属类的静态成员变量和成员方法</strong></p>

<h4 id="静态代码块">静态代码块</h4>

<p>请看代码块相关内容。</p>

<h4 id="静态导入">静态导入</h4>

<pre><code class="language-java">// 导入某个特定的静态方法
import static packageName.className.methonName;

// 导入类中的所有静态成员
import static packageName.className.*;
</code></pre>

<p>可以在当前类中直接用方法名调用静态方法，不必再通过类名来访问。</p>

<h3 id="final-修饰符">final 修饰符</h3>

<p><strong>最终的，不可改变</strong></p>

<h4 id="final-变量">final 变量</h4>

<p>final 变量即常量，仅可以赋值一次。</p>

<p>final 修饰的成员变量，要显示初始化，如果没有只能在构造函数中进行一次赋值</p>

<p>当变量为引用类型的时候，不可以改变引用对象，但可以改变对象的属性等。</p>

<h4 id="final-方法">final 方法</h4>

<p>final 可以被子类继承，但不可以覆盖。</p>

<h4 id="final-类">final 类</h4>

<p>final 类不可继承。</p>

<h4 id="final-static">final static</h4>

<p>成员变量，必须显示初始化，不可以修改，成员方法不可覆盖，可以通过类名直接访问。</p>

<h3 id="abstract-修饰符">Abstract 修饰符</h3>

<p>用来定义抽象方法和抽象类。</p>

<p><strong>abstract 不可以 与 final , private , static 共存</strong></p>

<ol>
<li><p>Abstract 修饰后，必须通过类继承或者接口实现来重写，否则就是摆设。</p></li>

<li><p>final 修饰的类 \ 方法 \ 属性均不可再次更改，故而不可以被重写。</p></li>

<li><p>private 修饰的类只可以定义在内部类；private 修饰的方法 \ 属性只可以在类中调用，重写时是访问不到这些方法和属性的。</p></li>

<li><p>static 静态的，其修饰的方法 \ 属性，是随着类的创建而创建，类的消亡而消亡，在编译时就已经确定的东西；但是 abstract 是 dynamic（动态）的，其必须通过类继承或接口实现来动态重写 abstract 方法。</p></li>
</ol>

<h3 id="synchronized-修饰符">Synchronized 修饰符</h3>

<p>Synchronized 关键字声明的方法同一时间只能被一个线程访问</p>

<h3 id="transient-修饰符">Transient 修饰符</h3>

<p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机 (JVM) 跳过该特定的变量。</p>

<p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>

<h3 id="volatile-修饰符">Volatile 修饰符</h3>

<p>Volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>

<p>一个 volatile 对象引用可能是 null。</p>

</div>


<div class="boo">
	<span></span>
</div>
<div class="footer">
	@XIZERO Powered by <a href="http://hugo.spf13.com/">Hugo</a> and <a href="#">bigbig</a>
</div>
</body>
</html>

