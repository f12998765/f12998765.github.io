<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.18.1" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="alternate" href="http://hugo.xizero.com//index.xml" type="application/rss+xml" title="XIZERO">
<link href="http://hugo.xizero.com/css/block.css" rel="stylesheet">
<script src="http://hugo.xizero.com/js/jqury.min.js"></script>
<script src="http://hugo.xizero.com/js/top.js"></script>


<title>Java 泛型 - XIZERO</title>
</head>
<body>

<div id="gotop" title="🚀 go top"></div>


<div class="titlist">
	<span><a href="http://hugo.xizero.com/">Home</a></span>
	<span><a href="http://hugo.xizero.com//tags/">Tags</a></span>
	<span><a href="http://hugo.xizero.com//about">About</a></span>
</div>



<link href="http://hugo.xizero.com/css/context.css" rel="stylesheet">
<link href="http://hugo.xizero.com/css/tomorrow.min.css" rel="stylesheet">
<script src="http://hugo.xizero.com/js/high.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<div class="tit">
	Java 泛型
</div>

<div class="toc">
	<nav id="TableOfContents">
<ul>
<li><a href="#泛型">泛型</a>
<ul>
<li><a href="#泛型是什么">泛型是什么?</a></li>
<li><a href="#泛型编程">泛型编程</a>
<ul>
<li><a href="#泛型类-容器类">泛型类/容器类</a></li>
<li><a href="#泛型接口">泛型接口</a></li>
<li><a href="#泛型方法">泛型方法</a></li>
</ul></li>
<li><a href="#泛型的继承">泛型的继承</a>
<ul>
<li><a href="#泛型类的继承">泛型类的继承</a></li>
<li><a href="#泛型类实现泛型接口">泛型类实现泛型接口</a></li>
<li><a href="#泛型接口继承泛型接口">泛型接口继承泛型接口</a></li>
</ul></li>
<li><a href="#通配符和上下界">通配符和上下界</a>
<ul>
<li><a href="#通配符">通配符 ?</a></li>
<li><a href="#上下界">上下界</a></li>
</ul></li>
<li><a href="#pecs原则">PECS原则</a></li>
<li><a href="#和-t-的区别">? 和 T 的区别</a></li>
<li><a href="#泛型的实现原理">泛型的实现原理</a>
<ul>
<li><a href="#type-erasure-http-docs-oracle-com-javase-tutorial-java-generics-erasure-html"><a href="http://docs.oracle.com/javase/tutorial/java/generics/erasure.html">Type Erasure</a></a></li>
<li><a href="#几种擦除">几种擦除</a></li>
<li><a href="#类型擦除的相关">类型擦除的相关</a></li>
</ul></li>
<li><a href="#参考">参考</a></li>
</ul></li>
</ul>
</nav>
</div>

<div class="con">
	

<h1 id="泛型">泛型</h1>

<h2 id="泛型是什么">泛型是什么?</h2>

<p>泛型是一种编译器机制，在编写代码时<strong>参数化类型</strong>，在实例化化时<strong>指定</strong>。</p>

<h2 id="泛型编程">泛型编程</h2>

<h3 id="泛型类-容器类">泛型类/容器类</h3>

<blockquote>
<p>泛型类中依然可以使用基本类型和引用类型，不一定都要参数化类型</p>
</blockquote>

<p>定义一个泛型类</p>

<blockquote>
<p>在类名后使用 &lt;&gt; 定义一个参数化类型。</p>
</blockquote>

<pre><code class="language-java">public class App&lt;T&gt; {
    private T x;

    public T getX() {
        return x;
    }

    public void setX(T x) {
        this.x = x;
    }
}
</code></pre>

<p>实例化泛型类</p>

<pre><code class="language-java">public class Main{
    public static void main(String[] args) {
        
        //指定类型为 String
        App&lt;String&gt; app = new App&lt;&gt;();
        app.setX(&quot;Hello World!&quot;);
        System.out.println(app.getX()); //Hello World!

        //指定类型为 Integer
        App&lt;Integer&gt; app1 = new App&lt;&gt;();
        app1.setX(100);
        System.out.println(app1.getX()); // 100
    }
}
</code></pre>

<blockquote>
<p>实例化时指定的参数类型必须是类，不能是<strong>基本类型</strong>，原因看 泛型的实现原理 。</p>
</blockquote>

<p>定义一个有多个参数类型的泛型类</p>

<blockquote>
<p>在 &lt;&gt; 中可以定义多个参数化类型，之间用 , 隔开</p>
</blockquote>

<pre><code class="language-java">public class App1&lt;T,U,B&gt;{

}
</code></pre>

<p>实例化</p>

<pre><code class="language-java">App1&lt;String,Integer,String&gt; app1 = new App1&lt;&gt;();
</code></pre>

<p>定义一个泛型抽象类</p>

<pre><code class="language-java">public abstract class App2&lt;T&gt; {
    private T y;

    public T getY() {
        return y;
    }

    public void setY(T y) {
        this.y = y;
    }
}
</code></pre>

<p>继承抽象泛型类</p>

<pre><code class="language-java">public class App3 extends App2&lt;String&gt; {
    public static void main(String[] args) {
        App3 app3 = new App3();
        app3.setY(&quot;泛型抽象类&quot;);
        System.out.println(app3.getY());
    }
}
</code></pre>

<blockquote>
<p>参数化类型的名称可以自定义，常用的有KTVE，具体含义看 。</p>
</blockquote>

<h3 id="泛型接口">泛型接口</h3>

<p>定义一个泛型接口</p>

<blockquote>
<p>接口中参数化类型的定义和类的一样</p>
</blockquote>

<pre><code class="language-java">public interface IApp&lt;T&gt;{
    public T get();
}
</code></pre>

<p>接口继承泛型接口</p>

<pre><code class="language-java">public interface IApp1 extends IApp&lt;String&gt; {
    public String getAll();
}
</code></pre>

<p>泛型接口实现</p>

<pre><code class="language-java">public  class AppImpl implements IApp&lt;String&gt; {
    @Override
    public String get() {
        return null;
    }
}
</code></pre>

<h3 id="泛型方法">泛型方法</h3>

<blockquote>
<p>泛型方法不只可以泛型类、泛型接口中定义，<strong>普通类</strong>中也可以</p>
</blockquote>

<p>定义一个泛型方法</p>

<blockquote>
<p>在普通方法中定义参数化类型，在访问修饰符之后，返回类型之前，使用 &lt;&gt; 定义。</p>
</blockquote>

<pre><code class="language-java">//使用参数化类型定义参数的类型
public &lt;T&gt; void hello(T t){
    System.out.println(&quot;Hello&quot;+t);
}

//使用参数化类型定义返回类型
public &lt;T&gt; T hello2(){
    return null;
}

//一起使用
public &lt;T&gt; T hello3(T t){
    return t;
}
</code></pre>

<p>定义一个静态的泛型方法</p>

<blockquote>
<p>在静态泛型中定义参数化类型，在static 之后，返回类型之前</p>
</blockquote>

<pre><code class="language-java">public static &lt;T&gt; T world(T t){
    return t;
}
</code></pre>

<p>一个可变参数的例子</p>

<pre><code class="language-java">public static &lt;T&gt; void out(T... args) {
    for (T t : args) {
        System.out.println(t);
    }
}
</code></pre>

<p>使用泛型方法</p>

<pre><code class="language-java">//像普通的方法一样用
app.hello();
//指定参数化类型
app.&lt;String&gt;hello();
//静态方法也一样
App.world();
App.&lt;String&gt;world();
</code></pre>

<h2 id="泛型的继承">泛型的继承</h2>

<h3 id="泛型类的继承">泛型类的继承</h3>

<blockquote>
<p>类型参数是当前类定义的。</p>
</blockquote>

<pre><code class="language-java">//type parameter of App1
public class App1&lt;T&gt; extends App0&lt;T&gt;{

}
</code></pre>

<h3 id="泛型类实现泛型接口">泛型类实现泛型接口</h3>

<pre><code class="language-java">public class App&lt;T&gt; extends IApp&lt;T&gt;{

}
</code></pre>

<h3 id="泛型接口继承泛型接口">泛型接口继承泛型接口</h3>

<pre><code class="language-java">public class IApp1&lt;T&gt; extends IApp0&lt;T&gt;{

}
</code></pre>

<h2 id="通配符和上下界">通配符和上下界</h2>

<h3 id="通配符">通配符 ?</h3>

<p>通配符 ? 表示未知类型，不确定类型。</p>

<p><strong>只是用来在实例化时填充</strong></p>

<p>例</p>

<pre><code class="language-java">//定义一个通用的容器类引用
App&lt;?&gt; app;

//指向不同对象
app = new App&lt;String&gt;();

app = new App&lt;Integer&gt;();
</code></pre>

<h3 id="上下界">上下界</h3>

<p>关键字: extends super</p>

<ul>
<li><p>&lt; ? extends T&gt; : 声明上界，表示参数化的类型是 T 或 T 的子类型</p></li>

<li><p>&lt; ? super T&gt;：声明下界，表示参数的类型是 T 或 T 的父类型，直至 Object</p></li>
</ul>

<p>理解通配符和上下界的三个方面</p>

<ul>
<li>引用指向的实现对象是否在上下界范围内</li>
<li>添加元素时，注意类型是否确定，注意多态（父类引用指向子类实现对象）</li>
<li>返回值的类型</li>
</ul>

<p><strong>深入理解 &lt; ? extends T&gt;</strong></p>

<pre><code class="language-java">public class Main {
    static class A{};
    static class B extends A{};
    static class C extends B{};
    
    public static void main(String[] args) {
        List&lt;? extends A&gt; list = new ArrayList&lt;B&gt;();
        //编译器报错
        //list.add(new A());
        //list.add(new B());
        //list.add(new C());
        list.add(null);

        B b = list.get(0);
    }
}
</code></pre>

<p>list 指向的是 A 或者 A 的子类型的ArrayList 对象</p>

<p>list 不能添加非空元素，原因是 <strong>编译器无法确定List所持有的类型</strong></p>

<p>但可以取出时，值得类型是 A ，因为多态，父类引用指向子类实现。</p>

<p><strong>深入理解 &lt; ? super T&gt;</strong></p>

<pre><code class="language-java">public class Main {
    static class A{};
    static class B extends A{};
    static class C extends B{};
    public static void main(String[] args) {
        List&lt;? super B&gt; list = new ArrayList&lt;B&gt;();
        //注释掉的编译错误
        //list.add(new A());
        list.add(new B());
        list.add(new Object());
        //list.add(null);
    }
}
</code></pre>

<p>List&lt; ? super B&gt; list 可以指向是 B 或 B 的父类型的 ArrayList 对象</p>

<p>但是可以添加的元素类型应该是 B 或 B 的子类型，可以添加原因也是多态</p>

<p>从list中取值，返回的是 Object</p>

<h2 id="pecs原则">PECS原则</h2>

<p>如果要从集合中读取类型T的数据，并且<strong>不能写入</strong>，可以使用 ? extends 通配符；(Producer Extends)</p>

<p>如果要从集合中写入类型T的数据，并且<strong>不需要读取</strong>，可以使用 ? super 通配符；(Consumer Super)</p>

<p>如果既要存又要取，那么就不要使用任何通配符。</p>

<p>出 处 ：<a href="http://flyingcat2013.blog.51cto.com/7061638/1616068">Java泛型中的PECS原则</a></p>

<h2 id="和-t-的区别">? 和 T 的区别</h2>

<ul>
<li><p>? 用在<strong>实例</strong>泛型时，填充范围。</p></li>

<li><p>T 用在<strong>定义</strong>泛型时，参数化类型。</p></li>
</ul>

<blockquote>
<p>与上下界一起使用时，区别还是一样。</p>
</blockquote>

<h2 id="泛型的实现原理">泛型的实现原理</h2>

<p>泛型的实现在编译阶段，通过<strong>类型擦除</strong>实现</p>

<h3 id="type-erasure-http-docs-oracle-com-javase-tutorial-java-generics-erasure-html"><a href="http://docs.oracle.com/javase/tutorial/java/generics/erasure.html">Type Erasure</a></h3>

<p>Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming.</p>

<p>Java 引入泛型，可以在编译时提供更严格的类型检查，并且支持泛型编程。</p>

<p>To implement generics, the Java compiler applies type erasure to:</p>

<p>为了实现泛型，java 编译器使用类型擦除 ：</p>

<ul>
<li>Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.</li>
<li>Insert type casts if necessary to preserve type safety.</li>

<li><p>Generate bridge methods to preserve polymorphism in extended generic types.</p></li>

<li><p>将所有参数类型替换成其边界，如果没有边界替换成 Object 。因此，产生的字节码文件仅仅包含普通类、接口和方法。</p></li>

<li><p>必要时添加类型转换以保存类型安全</p></li>

<li><p>生成桥方法以在扩展泛型时保持多态性</p></li>
</ul>

<p>Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.</p>

<p>类型擦除确保不因为参数化类型而创建新类； 因此，泛型不会产生运行时开销。</p>

<h3 id="几种擦除">几种擦除</h3>

<ol>
<li><T>  &ndash;&gt; Object</li>
<li>&lt;? extends T&gt; &ndash;&gt; T</li>
<li>&lt;? super T&gt; &ndash;&gt; Object</li>
<li>添加桥接方法，保证多态性</li>
</ol>

<p>与之前的深入理解有关</p>

<h3 id="类型擦除的相关">类型擦除的相关</h3>

<p>1.类型擦除，在编译之前进行类型检查</p>

<p>2.泛型与重载</p>

<p>因为类型擦除，所以下面的两个方法的参数类型相同，会报错，both methods hava same erasure.</p>

<pre><code>public void a(List&lt;Object&gt; list){};
public void a(List&lt;String&gt; list){};
</code></pre>

<p>3.泛型与多态</p>

<p>会生成桥方法，以保证多态</p>

<p>4.泛型与static</p>

<p>类的参数化类型不能定义静态变量和方法。</p>

<p>但是泛型方法可以定义成静态方法，它使用的自己的参数类型。</p>

<pre><code>public static &lt;T&gt; T get( STring s){};
</code></pre>

<p>泛型类的所有静态变量是共享的。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="http://www.cnblogs.com/sharewind/archive/2012/11/26/2788698.html">Java泛型通配符extends与super</a></li>
<li><a href="http://www.hollischuang.com/archives/255">Java泛型中extends和super的理解</a></li>
<li><a href="http://www.hollischuang.com/archives/226">Java的类型擦除</a></li>
<li><a href="http://blog.csdn.net/lonelyroamer/article/details/7868820">java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></li>
</ul>

</div>

<link href="http://hugo.xizero.com/css/footer.css" rel="stylesheet">

<div class="footer">
	<div class="_hr"><span></span></div>
	@XIZERO Powered by <a href="http://hugo.spf13.com/">Hugo</a> and <a href="#">bigbig</a>
</div>

</body>
</html>

