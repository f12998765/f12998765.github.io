<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.18.1" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="alternate" href="https://www.xizero.com//index.xml" type="application/rss+xml" title="XIZERO">
<link href="https://www.xizero.com/css/tomorrow.min.css" rel="stylesheet">
<link href="https://www.xizero.com//css/main.css" rel="stylesheet">
<link href="https://www.xizero.com/css/jqcloud.css" rel="stylesheet">
<script src="https://www.xizero.com/js/high.min.js"></script>
<script src="https://www.xizero.com/js/jqury.min.js"></script>
<script src="https://www.xizero.com/js/top.js"></script>
<script src="https://www.xizero.com/js/jqcloud.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<title>Java 核心类 - XIZERO</title>
</head>
<body>

<div id="gotop" title="🚀 go top"></div>

<div class="top">

	<div class="gos">
		<span class="go"><a href="https://www.xizero.com/">Home</a></span>
		<span class="go"><a href="/tags/">Tags</a></span>
		<span class="go"><a href="/about/">About</a></span>
	</div>
	
	
		<div class="tit">
			Java 核心类
		</div>

	

</div>




<div class="con">
	

<h1 id="java-lang-object">java.lang.Object</h1>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>equals</td>
<td>将该对象与传入的对象比较</td>
</tr>

<tr>
<td>toString</td>
<td>返回该对象的说明</td>
</tr>

<tr>
<td>hashCode</td>
<td>返回该对象的一个哈希值</td>
</tr>

<tr>
<td>getClass</td>
<td>返回该对象的一个java.lang.Class对象</td>
</tr>
</tbody>
</table>

<h1 id="java-lang-string">java.lang.String</h1>

<p>String 对象表示一个字符串。一个String对象是常量。</p>

<h2 id="创建">创建</h2>

<pre><code class="language-java">//常见，直接将字符串赋值给对象
String s = &quot;java is cool&quot;;

//使用new来构建一个String对象
String m = new String(&quot;Hello&quot;);
</code></pre>

<h2 id="字符串比较">字符串比较</h2>

<p><strong>字符串赋值和new关键字赋值的不同。</strong></p>

<pre><code class="language-java">String s1=&quot;Java&quot;;
String s2=&quot;Java&quot;;
if(s1==s2){ }//ture
</code></pre>

<pre><code class="language-java">String s1 = new String(&quot;Java&quot;);
String s2 = new String(&quot;Java&quot;);
if(s1 == s2){ }//false
</code></pre>

<p><strong>equals方法</strong></p>

<pre><code class="language-java">if(s1 != null &amp;&amp; s1.equals(&quot;java&quot;))   //s1为空时，会有运行时异常
if(&quot;Java&quot;.equals(s1)   //常用
</code></pre>

<h2 id="字符串赋值">字符串赋值</h2>

<ul>
<li>字符串以<code>&quot;</code>开始和结束，不可以在结束双引号之前换行。</li>
<li>可以使用加号连接符<code>+</code>将多个字符串连接起来。</li>
<li>将 String 与基本类型或其他类型连接，或调用后者的<code>toString()</code>方法。</li>
</ul>

<h2 id="switch">switch</h2>

<p>从 Java 7开始，可以对一个 String 使用switch 语句。</p>

<h2 id="string-类的方法">String 类的方法</h2>

<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>public char charAt(int index)</td>
<td>返回指定索引的字符</td>
</tr>

<tr>
<td>public String concat(String s)</td>
<td>在末尾连接字符串，并返回结果</td>
</tr>

<tr>
<td>public boolean equals(String s)</td>
<td>比较字符串的值</td>
</tr>

<tr>
<td>public boolean startWith(String prefix)</td>
<td>测试是否以指定的前缀开头</td>
</tr>

<tr>
<td>public boolean endsWith(String suffix)</td>
<td>测试是否以指定的后缀结尾</td>
</tr>

<tr>
<td>public int indexOf(String substring)</td>
<td>返回指定子字符串第一次出现的索引位置，不存在，返回 -1</td>
</tr>

<tr>
<td>public int indexOf(String substring ,int formIndex)</td>
<td>返回指定子字符串从指定索引开始的出现的第一次索引位置，不存在，返回 -1</td>
</tr>

<tr>
<td>public int lastIndexOf(String substring)</td>
<td>返回指定字符串最后一次出现的索引位置,不存在，返回 -1</td>
</tr>

<tr>
<td>public int lastindexOf(String substring,int formIndex)</td>
<td>返回指定子字符串从指定索引开始的出现的最后一次索引位置，不存在，返回 -1</td>
</tr>

<tr>
<td>public String substring(int beginIndex)</td>
<td>返回从指定索引开始的，到末尾的子字符串</td>
</tr>

<tr>
<td>public String substring(int beginIndex,int endIndex)</td>
<td>返回从beginIndex开始到endIndex结束的子字符串</td>
</tr>

<tr>
<td>public String replace(char oldChar,char newChar)</td>
<td>将oldChar 替换为newOld，并返回新的字符串</td>
</tr>

<tr>
<td>public int length()</td>
<td>返回字符串的长度</td>
</tr>

<tr>
<td>public boolean isEmpty()</td>
<td>判断字符串是否为空</td>
</tr>

<tr>
<td>public String[] split(String regEx)</td>
<td>使用指定的正则表达式分割字符串</td>
</tr>

<tr>
<td>public char[] toCharArray()</td>
<td>将字符串转换为字符的数组</td>
</tr>

<tr>
<td>public String toLowerCase()</td>
<td>将所有字符转换为小写</td>
</tr>

<tr>
<td>public String toUpperCase()</td>
<td>将所有字符转换为大写</td>
</tr>

<tr>
<td>public String trim()</td>
<td>去掉头部和尾部的空格</td>
</tr>

<tr>
<td>public static String valueOf( )</td>
<td>将基本类型、字符数组、对象转换为一个字符串</td>
</tr>
</tbody>
</table>

<h2 id="java-lang-stringbuffer和java-lang-stringbuilder">java.lang.StringBuffer和java.lang.StringBuilder</h2>

<p>String 对象不可变，添加或插入字符都会创建一个新的对象。</p>

<h3 id="stringbuffer和stringbuilder的选择">StringBuffer和StringBuilder的选择</h3>

<p>一般用 StringBulider
需要同步选择 StringBuffer</p>

<h3 id="方法">方法</h3>

<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>public int capacity()</td>
<td>返回对象的容量</td>
</tr>

<tr>
<td>public int length()</td>
<td>返回存储字符串的长度</td>
</tr>

<tr>
<td>public String__ append(String string)</td>
<td>将string添加到末尾</td>
</tr>

<tr>
<td>public String__ insert (int offset,String string)</td>
<td>在指定位置插入字符串</td>
</tr>

<tr>
<td>public String toString()</td>
<td>返回一个String对象</td>
</tr>
</tbody>
</table>

<h1 id="基本类型包装器">基本类型包装器</h1>

<h2 id="包装类">包装类</h2>

<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应包装类</th>
</tr>
</thead>

<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>

<tr>
<td>short</td>
<td>Short</td>
</tr>

<tr>
<td>int</td>
<td>Integer</td>
</tr>

<tr>
<td>long</td>
<td>Long</td>
</tr>

<tr>
<td>char</td>
<td>Character</td>
</tr>

<tr>
<td>float</td>
<td>Float</td>
</tr>

<tr>
<td>double</td>
<td>Double</td>
</tr>

<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>

<blockquote>
<p>除了Integer和Character类以后，其它类的类名和基本数据类型相同，只是类名首字母大写。</p>
</blockquote>

<h2 id="包装器类的方法">包装器类的方法</h2>

<ol>
<li><strong>构造方法</strong>：<strong>基本类型</strong> &ndash;&gt; 包装器类</li>
<li><strong>构造方法</strong>：<strong>字符串</strong> &ndash;&gt; 包装器类</li>
</ol>

<ul>
<li>带有基本值参数并创建包装类对象的构造函数  <code>Integer obj=new Integer(145);</code></li>
<li>带有字符串参数并创建包装类对象的构造函数  <code>Integer obj=new Integer(&quot;-45.36&quot;);</code></li>
</ul>

<ol>
<li><strong>parse___</strong>：<strong>字符串</strong> &ndash;&gt; 基本类型</li>
<li><strong>___Value</strong>：<strong>包装器类</strong> &ndash;&gt; 基本类型</li>
</ol>

<ul>
<li>可生成对象基本值的typeValue方法  <code>obj.intValue();</code></li>
<li>将字符串转换为基本值的 parseType方法  <code>Integer.parseInt(args[0]);</code></li>
</ul>

<ol>
<li><strong>toString</strong>：<strong>包装器类</strong> &ndash;&gt;字符串</li>
<li><strong>___.valueOf</strong>：<strong>字符串</strong> &ndash;&gt;包装类</li>
</ol>

<h2 id="自动装箱-拆箱">自动装箱/拆箱</h2>

<p>JDK1.5的新特性：自动装箱/拆箱(Autoboxing/unboxing)</p>

<p>自动装箱
 - 基本类型就自动地封装到与它相似类型的包装中，如：Integer i = 100；
 - 本质上是，编译器编译时自动添加：Integer i = new Integer(100);</p>

<p>自动拆箱
 - 包装类对象自动转换成基本数据类型。如：int a = new Integer(100);
 - 本质是上，编译器编译时自动添加：int a = new Integer(100).intValue();</p>

<h2 id="字符串与基本类型的相互转换">字符串与基本类型的相互转换</h2>

<h3 id="基本类型-字符串">基本类型 &ndash;&gt; 字符串</h3>

<ol>
<li>包装类 的 <code>toString()</code> 方法</li>
<li>String类 的 <code>valueOf()</code> 方法</li>
<li>空字符串<code>&quot; &quot;</code> + 基本类型</li>
</ol>

<h3 id="字符串-基本类型">字符串 &ndash;&gt; 基本类型</h3>

<ol>
<li>包装类的 parseXxx 静态方法</li>
<li>包装类的 valueOf() 方法转换为基本类型的包装类，自动拆箱</li>
</ol>

<h1 id="java-lang-class">java.lang.Class</h1>

<h2 id="关于">关于</h2>

<ol>
<li>每次 JVM 创建对象时，都会创建一个 java.lang.Class 对象来描述该对象的类型。</li>
<li>同一个类的所有实例，都共享同一个 Class 对象。</li>
<li>Class 类没有 public 的构造方法，只能有 JVM 创建.</li>
</ol>

<h2 id="获取-class-实例">获取 Class 实例</h2>

<ol>
<li>实例变量 obj.getClass()；</li>
<li>对象类文件 Object.class；</li>
<li>Class的静态方法 forName();</li>
</ol>

<blockquote>
<p>数组只能用<code>.getClass</code>，不可以用 <code>.class</code></p>
</blockquote>

<h2 id="使用">使用</h2>

<h3 id="class-forname">Class.forName()</h3>

<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>static Class&lt;?&gt; forName(String className)</td>
<td>Returns the Class object associated with the class or interface with the given string name.</td>
</tr>

<tr>
<td>static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</td>
<td>Returns the Class object associated with the class or interface with the given string name, using the given class loader.</td>
</tr>
</tbody>
</table>

<p><strong>参数</strong>
- name - 类的全名
- initialize - 表示是否初始化类
- loader - 表示加载时使用的类加载器</p>

<p>Class.forName(className)实际上是调用Class.forName(className,true, this.getClass().getClassLoader())，默认初始化类，使用默认的类加载器。Class.forName（className）加载类时则已初始化。</p>

<p>CLass.forName()的作用是要求JVM 查找并加载指定的类。
静态代码段在类加载时执行。</p>

<h3 id="newlnstance">newlnstance()</h3>

<p>用来创建实例</p>

<p><strong>和new 的区别</strong>
- newlnstance ： 使用时类必须已经加载连接，只能调用无参构造函数
- new ： 可以调用任意公共构造函数</p>

<p>构造函数调用 newlnstance 可以含参。</p>

<h3 id="判断类型">判断类型</h3>

<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>
<td>判断指定注解是否存在于该元素上</td>
</tr>

<tr>
<td>isArray()</td>
<td>判断该对象是否表示数组</td>
</tr>

<tr>
<td>isAnnotation()</td>
<td>判断该对象是否表示注解类型</td>
</tr>

<tr>
<td>isAnonymousClass()</td>
<td>當且僅當底層類是匿名類此方法返回true</td>
</tr>

<tr>
<td>isAssignableFrom(Class&lt;?&gt; cls)</td>
<td>判断该对象是否与另一个Class对象相同，或者是他的超类或接口</td>
</tr>

<tr>
<td>isInstance(Object obj)</td>
<td>判断 obj 是否兼容于该 class 对象，即 obj 是否是 class 的自身实例或子类实例</td>
</tr>

<tr>
<td>isInterface()</td>
<td>判断该对象是否表示接口类型</td>
</tr>

<tr>
<td>isEnum()</td>
<td>判断该对象是否表示枚举类型</td>
</tr>

<tr>
<td>isSynthetic()</td>
<td>判断该对象是否表示合成类</td>
</tr>

<tr>
<td>isMemberClass()</td>
<td>判断该对象是否表示内部类/成员类</td>
</tr>

<tr>
<td>isLocalClass()</td>
<td>判断该对象是否表示局部类</td>
</tr>

<tr>
<td>isPrimitive()</td>
<td>判断该对象是否表示基本类型</td>
</tr>
</tbody>
</table>

<h1 id="java-lang-system">java.lang.System</h1>

<h1 id="java-lang-scaner">java.lang.Scaner</h1>

</div>


<div class="boo">
	<span></span>
</div>
<div class="footer">
	@XIZERO Powered by <a href="http://hugo.spf13.com/">Hugo</a> and <a href="#">bigbig</a>
</div>
</body>
</html>

